import {
  require_jsx_runtime
} from "./chunk-XX3AYODZ.js";
import {
  require_react_dom
} from "./chunk-CJXG4QEB.js";
import {
  require_react
} from "./chunk-5O6XVQYV.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-PLDDJCW6.js";

// ../../node_modules/@react-native/normalize-color/index.js
var require_normalize_color = __commonJS({
  "../../node_modules/@react-native/normalize-color/index.js"(exports, module) {
    "use strict";
    function normalizeColor3(color) {
      if (typeof color === "number") {
        if (color >>> 0 === color && color >= 0 && color <= 4294967295) {
          return color;
        }
        return null;
      }
      if (typeof color !== "string") {
        return null;
      }
      const matchers = getMatchers();
      let match;
      if (match = matchers.hex6.exec(color)) {
        return parseInt(match[1] + "ff", 16) >>> 0;
      }
      const colorFromKeyword = normalizeKeyword(color);
      if (colorFromKeyword != null) {
        return colorFromKeyword;
      }
      if (match = matchers.rgb.exec(color)) {
        return (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | // b
        255) >>> // a
        0;
      }
      if (match = matchers.rgba.exec(color)) {
        if (match[6] !== void 0) {
          return (parse255(match[6]) << 24 | // r
          parse255(match[7]) << 16 | // g
          parse255(match[8]) << 8 | // b
          parse1(match[9])) >>> // a
          0;
        }
        return (parse255(match[2]) << 24 | // r
        parse255(match[3]) << 16 | // g
        parse255(match[4]) << 8 | // b
        parse1(match[5])) >>> // a
        0;
      }
      if (match = matchers.hex3.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          "ff",
          // a
          16
        ) >>> 0;
      }
      if (match = matchers.hex8.exec(color)) {
        return parseInt(match[1], 16) >>> 0;
      }
      if (match = matchers.hex4.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          match[4] + match[4],
          // a
          16
        ) >>> 0;
      }
      if (match = matchers.hsl.exec(color)) {
        return (hslToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // s
          parsePercentage(match[3])
          // l
        ) | 255) >>> // a
        0;
      }
      if (match = matchers.hsla.exec(color)) {
        if (match[6] !== void 0) {
          return (hslToRgb(
            parse360(match[6]),
            // h
            parsePercentage(match[7]),
            // s
            parsePercentage(match[8])
            // l
          ) | parse1(match[9])) >>> // a
          0;
        }
        return (hslToRgb(
          parse360(match[2]),
          // h
          parsePercentage(match[3]),
          // s
          parsePercentage(match[4])
          // l
        ) | parse1(match[5])) >>> // a
        0;
      }
      if (match = matchers.hwb.exec(color)) {
        return (hwbToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // w
          parsePercentage(match[3])
          // b
        ) | 255) >>> // a
        0;
      }
      return null;
    }
    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }
    function hslToRgb(h, s, l) {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      const r = hue2rgb(p, q, h + 1 / 3);
      const g = hue2rgb(p, q, h);
      const b = hue2rgb(p, q, h - 1 / 3);
      return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
    }
    function hwbToRgb(h, w, b) {
      if (w + b >= 1) {
        const gray = Math.round(w * 255 / (w + b));
        return gray << 24 | gray << 16 | gray << 8;
      }
      const red = hue2rgb(0, 1, h + 1 / 3) * (1 - w - b) + w;
      const green = hue2rgb(0, 1, h) * (1 - w - b) + w;
      const blue = hue2rgb(0, 1, h - 1 / 3) * (1 - w - b) + w;
      return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
    }
    var NUMBER = "[-+]?\\d*\\.?\\d+";
    var PERCENTAGE = NUMBER + "%";
    function call(...args) {
      return "\\(\\s*(" + args.join(")\\s*,?\\s*(") + ")\\s*\\)";
    }
    function callWithSlashSeparator(...args) {
      return "\\(\\s*(" + args.slice(0, args.length - 1).join(")\\s*,?\\s*(") + ")\\s*/\\s*(" + args[args.length - 1] + ")\\s*\\)";
    }
    function commaSeparatedCall(...args) {
      return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
    }
    var cachedMatchers;
    function getMatchers() {
      if (cachedMatchers === void 0) {
        cachedMatchers = {
          rgb: new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER)),
          rgba: new RegExp(
            "rgba(" + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + "|" + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ")"
          ),
          hsl: new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
          hsla: new RegExp(
            "hsla(" + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + "|" + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ")"
          ),
          hwb: new RegExp("hwb" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
          hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#([0-9a-fA-F]{6})$/,
          hex8: /^#([0-9a-fA-F]{8})$/
        };
      }
      return cachedMatchers;
    }
    function parse255(str) {
      const int = parseInt(str, 10);
      if (int < 0) {
        return 0;
      }
      if (int > 255) {
        return 255;
      }
      return int;
    }
    function parse360(str) {
      const int = parseFloat(str);
      return (int % 360 + 360) % 360 / 360;
    }
    function parse1(str) {
      const num = parseFloat(str);
      if (num < 0) {
        return 0;
      }
      if (num > 1) {
        return 255;
      }
      return Math.round(num * 255);
    }
    function parsePercentage(str) {
      const int = parseFloat(str);
      if (int < 0) {
        return 0;
      }
      if (int > 100) {
        return 1;
      }
      return int / 100;
    }
    function normalizeKeyword(name) {
      switch (name) {
        case "transparent":
          return 0;
        // http://www.w3.org/TR/css3-color/#svg-color
        case "aliceblue":
          return 4042850303;
        case "antiquewhite":
          return 4209760255;
        case "aqua":
          return 16777215;
        case "aquamarine":
          return 2147472639;
        case "azure":
          return 4043309055;
        case "beige":
          return 4126530815;
        case "bisque":
          return 4293182719;
        case "black":
          return 255;
        case "blanchedalmond":
          return 4293643775;
        case "blue":
          return 65535;
        case "blueviolet":
          return 2318131967;
        case "brown":
          return 2771004159;
        case "burlywood":
          return 3736635391;
        case "burntsienna":
          return 3934150143;
        case "cadetblue":
          return 1604231423;
        case "chartreuse":
          return 2147418367;
        case "chocolate":
          return 3530104575;
        case "coral":
          return 4286533887;
        case "cornflowerblue":
          return 1687547391;
        case "cornsilk":
          return 4294499583;
        case "crimson":
          return 3692313855;
        case "cyan":
          return 16777215;
        case "darkblue":
          return 35839;
        case "darkcyan":
          return 9145343;
        case "darkgoldenrod":
          return 3095792639;
        case "darkgray":
          return 2846468607;
        case "darkgreen":
          return 6553855;
        case "darkgrey":
          return 2846468607;
        case "darkkhaki":
          return 3182914559;
        case "darkmagenta":
          return 2332068863;
        case "darkolivegreen":
          return 1433087999;
        case "darkorange":
          return 4287365375;
        case "darkorchid":
          return 2570243327;
        case "darkred":
          return 2332033279;
        case "darksalmon":
          return 3918953215;
        case "darkseagreen":
          return 2411499519;
        case "darkslateblue":
          return 1211993087;
        case "darkslategray":
          return 793726975;
        case "darkslategrey":
          return 793726975;
        case "darkturquoise":
          return 13554175;
        case "darkviolet":
          return 2483082239;
        case "deeppink":
          return 4279538687;
        case "deepskyblue":
          return 12582911;
        case "dimgray":
          return 1768516095;
        case "dimgrey":
          return 1768516095;
        case "dodgerblue":
          return 512819199;
        case "firebrick":
          return 2988581631;
        case "floralwhite":
          return 4294635775;
        case "forestgreen":
          return 579543807;
        case "fuchsia":
          return 4278255615;
        case "gainsboro":
          return 3705462015;
        case "ghostwhite":
          return 4177068031;
        case "gold":
          return 4292280575;
        case "goldenrod":
          return 3668254975;
        case "gray":
          return 2155905279;
        case "green":
          return 8388863;
        case "greenyellow":
          return 2919182335;
        case "grey":
          return 2155905279;
        case "honeydew":
          return 4043305215;
        case "hotpink":
          return 4285117695;
        case "indianred":
          return 3445382399;
        case "indigo":
          return 1258324735;
        case "ivory":
          return 4294963455;
        case "khaki":
          return 4041641215;
        case "lavender":
          return 3873897215;
        case "lavenderblush":
          return 4293981695;
        case "lawngreen":
          return 2096890111;
        case "lemonchiffon":
          return 4294626815;
        case "lightblue":
          return 2916673279;
        case "lightcoral":
          return 4034953471;
        case "lightcyan":
          return 3774873599;
        case "lightgoldenrodyellow":
          return 4210742015;
        case "lightgray":
          return 3553874943;
        case "lightgreen":
          return 2431553791;
        case "lightgrey":
          return 3553874943;
        case "lightpink":
          return 4290167295;
        case "lightsalmon":
          return 4288707327;
        case "lightseagreen":
          return 548580095;
        case "lightskyblue":
          return 2278488831;
        case "lightslategray":
          return 2005441023;
        case "lightslategrey":
          return 2005441023;
        case "lightsteelblue":
          return 2965692159;
        case "lightyellow":
          return 4294959359;
        case "lime":
          return 16711935;
        case "limegreen":
          return 852308735;
        case "linen":
          return 4210091775;
        case "magenta":
          return 4278255615;
        case "maroon":
          return 2147483903;
        case "mediumaquamarine":
          return 1724754687;
        case "mediumblue":
          return 52735;
        case "mediumorchid":
          return 3126187007;
        case "mediumpurple":
          return 2473647103;
        case "mediumseagreen":
          return 1018393087;
        case "mediumslateblue":
          return 2070474495;
        case "mediumspringgreen":
          return 16423679;
        case "mediumturquoise":
          return 1221709055;
        case "mediumvioletred":
          return 3340076543;
        case "midnightblue":
          return 421097727;
        case "mintcream":
          return 4127193855;
        case "mistyrose":
          return 4293190143;
        case "moccasin":
          return 4293178879;
        case "navajowhite":
          return 4292783615;
        case "navy":
          return 33023;
        case "oldlace":
          return 4260751103;
        case "olive":
          return 2155872511;
        case "olivedrab":
          return 1804477439;
        case "orange":
          return 4289003775;
        case "orangered":
          return 4282712319;
        case "orchid":
          return 3664828159;
        case "palegoldenrod":
          return 4008225535;
        case "palegreen":
          return 2566625535;
        case "paleturquoise":
          return 2951671551;
        case "palevioletred":
          return 3681588223;
        case "papayawhip":
          return 4293907967;
        case "peachpuff":
          return 4292524543;
        case "peru":
          return 3448061951;
        case "pink":
          return 4290825215;
        case "plum":
          return 3718307327;
        case "powderblue":
          return 2967529215;
        case "purple":
          return 2147516671;
        case "rebeccapurple":
          return 1714657791;
        case "red":
          return 4278190335;
        case "rosybrown":
          return 3163525119;
        case "royalblue":
          return 1097458175;
        case "saddlebrown":
          return 2336560127;
        case "salmon":
          return 4202722047;
        case "sandybrown":
          return 4104413439;
        case "seagreen":
          return 780883967;
        case "seashell":
          return 4294307583;
        case "sienna":
          return 2689740287;
        case "silver":
          return 3233857791;
        case "skyblue":
          return 2278484991;
        case "slateblue":
          return 1784335871;
        case "slategray":
          return 1887473919;
        case "slategrey":
          return 1887473919;
        case "snow":
          return 4294638335;
        case "springgreen":
          return 16744447;
        case "steelblue":
          return 1182971135;
        case "tan":
          return 3535047935;
        case "teal":
          return 8421631;
        case "thistle":
          return 3636451583;
        case "tomato":
          return 4284696575;
        case "turquoise":
          return 1088475391;
        case "violet":
          return 4001558271;
        case "wheat":
          return 4125012991;
        case "white":
          return 4294967295;
        case "whitesmoke":
          return 4126537215;
        case "yellow":
          return 4294902015;
        case "yellowgreen":
          return 2597139199;
      }
      return null;
    }
    module.exports = normalizeColor3;
  }
});

// ../../node_modules/@tamagui/timer/dist/esm/index.mjs
var esm_exports2 = {};
__export(esm_exports2, {
  timer: () => timer
});
function timer() {
  let runs = 0;
  const typesOfRuns = /* @__PURE__ */ new Set(), timings = {};
  function print() {
    const typeRuns = runs / typesOfRuns.size;
    let totalTime = 0;
    const out = [`Ran ${typeRuns} per-type, ${runs} total`, ...[...typesOfRuns].map((name) => {
      if (name.endsWith("(ignore)")) return;
      const avg = `avg ${`${timings[name] / typeRuns}`.slice(0, 9).padEnd(9)}ms`, total = timings[name];
      return totalTime += total, `${name.slice(0, 30).padStart(31)} | ${avg} | total ${total}ms`;
    }), `                                    total ${totalTime}ms`].join(`
`);
    return console.info(out), out;
  }
  return {
    start(opts) {
      const quiet = opts?.quiet ?? true;
      function time3(strings, ...vars) {
        const elapsed = performance.now() - start, tag = templateToString(strings, ...vars);
        if (typesOfRuns.add(tag), runs++, timings[tag] ??= 0, timings[tag] += elapsed, !quiet) {
          let result = "";
          strings.forEach((str, i) => {
            result += `${str}${i === strings.length - 1 ? "" : vars[i]}`;
          }), console.info(`${`${elapsed}ms`.slice(0, 6).padStart(7)} |`, result);
        }
        start = performance.now();
      }
      let start = performance.now();
      return time3.print = print, time3;
    },
    profile() {
      return {
        timings,
        runs
      };
    },
    print
  };
}
function templateToString(strings, ...vars) {
  return strings.reduce((result, str, i) => result + str + (vars[i] !== void 0 ? vars[i] : ""), "");
}
var init_esm = __esm({
  "../../node_modules/@tamagui/timer/dist/esm/index.mjs"() {
  }
});

// ../../node_modules/@tamagui/web/dist/esm/helpers/createStyledContext.mjs
var import_react = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/web/dist/esm/helpers/pseudoDescriptors.mjs
var pseudoDescriptorsBase = {
  // order of keys here important! in priority order
  hoverStyle: {
    name: "hover",
    priority: 2
  },
  pressStyle: {
    name: "active",
    stateKey: "press",
    priority: 3
  },
  focusVisibleStyle: {
    name: "focus-visible",
    priority: 4,
    stateKey: "focusVisible"
  },
  focusStyle: {
    name: "focus",
    priority: 4
  },
  focusWithinStyle: {
    name: "focus-within",
    priority: 4,
    stateKey: "focusWithin"
  },
  disabledStyle: {
    name: "disabled",
    priority: 5,
    stateKey: "disabled"
  }
};
var pseudoPriorities = {
  hover: pseudoDescriptorsBase.hoverStyle.priority,
  press: pseudoDescriptorsBase.pressStyle.priority,
  focus: pseudoDescriptorsBase.focusStyle.priority,
  focusVisible: pseudoDescriptorsBase.focusVisibleStyle.priority,
  focusWithin: pseudoDescriptorsBase.focusWithinStyle.priority,
  disabled: pseudoDescriptorsBase.disabledStyle.priority
};
var pseudoDescriptors = {
  ...pseudoDescriptorsBase,
  enterStyle: {
    name: "enter",
    selector: ".t_unmounted",
    priority: 4
  },
  exitStyle: {
    name: "exit",
    priority: 5
  }
};
var defaultMediaImportance = Object.keys(pseudoDescriptors).length;

// ../../node_modules/@tamagui/web/dist/esm/helpers/mergeProps.mjs
var mergeProps = (defaultProps, props) => {
  const out = {};
  for (const key in defaultProps) key in props || (out[key] = defaultProps[key]);
  for (const key in props) mergeProp(out, defaultProps, props, key);
  return out;
};
var mergeComponentProps = (defaultProps, contextProps, props) => {
  let overriddenContext = null;
  if (!defaultProps && !contextProps) return [props, overriddenContext];
  if (defaultProps && !contextProps) return [mergeProps(defaultProps, props), overriddenContext];
  const out = {};
  for (const key in defaultProps) key in props || (out[key] = defaultProps[key]);
  for (const key in contextProps) {
    if (key in props) continue;
    const contextValue = contextProps[key];
    contextValue !== void 0 && (out[key] = contextValue);
  }
  for (const key in props) mergeProp(out, defaultProps, props, key), contextProps && key in contextProps && (overriddenContext ||= {}, overriddenContext[key] = props[key]);
  return [out, overriddenContext];
};
function mergeProp(out, defaultProps, props, key) {
  let val = props[key];
  if (defaultProps && key in defaultProps && (key in pseudoDescriptors || key[0] === "$") && val && typeof val == "object") {
    const defaultVal = defaultProps[key];
    defaultVal && typeof defaultVal == "object" && (val = mergeProps(defaultVal, val));
  }
  out[key] = val;
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/objectIdentityKey.mjs
function objectIdentityKey(obj) {
  let k = "";
  for (const key in obj) {
    k += key;
    const arg = obj[key];
    let type = typeof arg;
    if (!arg || type !== "object" && type !== "function") k += type + arg;
    else if (cache.has(arg)) k += cache.get(arg);
    else {
      let v = Math.random();
      cache.set(arg, v), k += v;
    }
  }
  return k;
}
var cache = /* @__PURE__ */ new WeakMap();

// ../../node_modules/@tamagui/web/dist/esm/helpers/createStyledContext.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var createReactContext = import_react.default[Math.random(), "createContext"];
function createStyledContext(defaultValues, namespace = "") {
  const OGContext = createReactContext(defaultValues), OGProvider = OGContext.Provider, Context = OGContext, scopedContexts = /* @__PURE__ */ new Map(), LastScopeInNamespace = createReactContext(namespace);
  function getOrCreateScopedContext(scope) {
    let ScopedContext = scopedContexts.get(scope);
    return ScopedContext || (ScopedContext = createReactContext(defaultValues), scopedContexts.set(scope, ScopedContext)), ScopedContext;
  }
  const getNamespacedScope = (scope) => namespace ? `${namespace}--${scope}` : scope, Provider = ({
    children,
    scope: scopeIn,
    // performance: avoid creating objects
    __disableMergeDefaultValues,
    ...values
  }) => {
    const scope = getNamespacedScope(scopeIn), next = import_react.default.useMemo(() => __disableMergeDefaultValues ? values : mergeProps(defaultValues, values), [objectIdentityKey(values)]);
    let ScopedProvider = OGProvider;
    return scope && (ScopedProvider = getOrCreateScopedContext(scope).Provider), (0, import_jsx_runtime.jsx)(LastScopeInNamespace.Provider, {
      value: scope,
      children: (0, import_jsx_runtime.jsx)(ScopedProvider, {
        value: next,
        children
      })
    });
  }, useStyledContext = (scopeIn = "") => {
    const lastScopeInNamespace = (0, import_react.useContext)(LastScopeInNamespace), scope = namespace ? scopeIn ? getNamespacedScope(scopeIn) : lastScopeInNamespace : scopeIn, context = scope ? getOrCreateScopedContext(scope) : OGContext;
    return import_react.default.useContext(context);
  };
  return Context.Provider = Provider, Context.props = defaultValues, Context.context = OGContext, Context.useStyledContext = useStyledContext, Context;
}

// ../../node_modules/@tamagui/web/dist/esm/contexts/ComponentContext.mjs
var import_react2 = __toESM(require_react(), 1);
var ComponentContext = createStyledContext({
  disableSSR: void 0,
  inText: false,
  language: null,
  animationDriver: null,
  setParentFocusState: null
});
var useConfiguration = () => (0, import_react2.useContext)(ComponentContext);

// ../../node_modules/@tamagui/web/dist/esm/contexts/GroupContext.mjs
var import_react3 = __toESM(require_react(), 1);
var GroupContext = (0, import_react3.createContext)(null);

// ../../node_modules/@tamagui/constants/dist/esm/constants.mjs
var import_react4 = __toESM(require_react(), 1);
var IS_REACT_19 = typeof import_react4.default.use < "u";
var isWeb = true;
var isWindowDefined = typeof window < "u";
var isServer = isWeb && !isWindowDefined;
var isClient = isWeb && isWindowDefined;
var useIsomorphicLayoutEffect = isServer ? import_react4.useEffect : import_react4.useLayoutEffect;
var isChrome = typeof navigator < "u" && /Chrome/.test(navigator.userAgent || "");
var isWebTouchable = isClient && ("ontouchstart" in window || navigator.maxTouchPoints > 0);
var isTouchable = !isWeb || isWebTouchable;
var isAndroid = false;
var isIos = process.env.TEST_NATIVE_PLATFORM === "ios";
var currentPlatform = "web";

// ../../node_modules/@tamagui/web/dist/esm/constants/constants.mjs
var THEME_CLASSNAME_PREFIX = "t_";
var FONT_DATA_ATTRIBUTE_NAME = "data-tamagui-font";
var stackDefaultStyles = {};
var webViewFlexCompatStyles = {
  display: "flex",
  alignItems: "stretch",
  flexDirection: "column",
  flexBasis: "auto",
  boxSizing: "border-box",
  position: process.env.TAMAGUI_POSITION_STATIC === "1" ? "static" : "relative",
  minHeight: 0,
  minWidth: 0,
  flexShrink: 0
};
Object.assign(stackDefaultStyles, webViewFlexCompatStyles);
var MISSING_THEME_MESSAGE = true ? `Can't find Tamagui configuration.
    
99% of the time this is due to having mis-matched versions of Tamagui dependencies.
Ensure that every "tamagui" and "@tamagui/*" dependency is pinned to exactly the same version.

We have a CLI tool to help check this: 

  npx @tamagui/cli check
` : "Missing theme.";

// ../../node_modules/@tamagui/web/dist/esm/config.mjs
var conf;
var setConfigCalledByThisInstance = false;
var haventCalledErrorMessage = true ? `
Haven't called createTamagui yet. ${MISSING_THEME_MESSAGE}
` : "âŒ Error 001";
var getConfigFromGlobalOrLocal = () => conf || (globalThis.__tamaguiConfig ? (!globalThis.__tamaguiHasWarnedGlobalFallback && !globalThis.__tamaguiPendingCheck && (globalThis.__tamaguiPendingCheck = true, setTimeout(() => {
  !setConfigCalledByThisInstance && !globalThis.__tamaguiHasWarnedGlobalFallback && (globalThis.__tamaguiHasWarnedGlobalFallback = true, console.warn("Tamagui: Using global config fallback. This may indicate duplicate tamagui instances (e.g., from Vite SSR bundling). This is handled automatically, but may cause issues.")), globalThis.__tamaguiPendingCheck = false;
}, 500)), globalThis.__tamaguiConfig) : null);
var getSetting = (key) => {
  const config = getConfigFromGlobalOrLocal();
  if (!config) throw new Error(haventCalledErrorMessage);
  return config.settings[key] ?? // @ts-expect-error
  config[key];
};
var setConfig = (next) => {
  setConfigCalledByThisInstance = true, conf = next, globalThis.__tamaguiConfig = next;
};
var setConfigFont = (name, font, fontParsed) => {
  const config = getConfigFromGlobalOrLocal();
  if (!config) throw new Error(haventCalledErrorMessage);
  config.fonts[name] = font, config.fontsParsed[`$${name}`] = fontParsed;
};
var getConfig = () => {
  const config = getConfigFromGlobalOrLocal();
  if (!config) throw new Error(true ? "Missing tamagui config, you either have a duplicate config, or haven't set it up. Be sure createTamagui is called before rendering. Also, make sure all of your tamagui dependencies are on the same version (`tamagui`, `@tamagui/package-name`, etc.) not just in your package.json, but in your lockfile." : "Err0");
  return config;
};
var getConfigMaybe = () => getConfigFromGlobalOrLocal();
var tokensMerged;
function setTokens(_) {
  tokensMerged = _;
}
var getTokens = ({
  prefixed
} = {}) => {
  const config = getConfigFromGlobalOrLocal();
  if (!config) throw new Error(haventCalledErrorMessage);
  const {
    tokens,
    tokensParsed
  } = config;
  return prefixed === false ? tokens : prefixed === true ? tokensParsed : tokensMerged;
};
var getTokenObject = (value, group) => getConfigFromGlobalOrLocal().specificTokens[value] ?? (group ? tokensMerged[group]?.[value] : tokensMerged[Object.keys(tokensMerged).find((cat) => tokensMerged[cat][value]) || ""]?.[value]);
var getToken = (value, group, useVariable = isWeb) => {
  const token = getTokenObject(value, group);
  return useVariable ? token?.variable : token?.val;
};
var getTokenValue = (value, group) => {
  if (!(value === "unset" || value === "auto")) return getToken(value, group, false);
};
var getThemes = () => getConfigFromGlobalOrLocal().themes;
var configListeners = /* @__PURE__ */ new Set();
var onConfiguredOnce = (cb) => {
  const config = getConfigFromGlobalOrLocal();
  config ? cb(config) : configListeners.add(cb);
};
var updateConfig = (key, value) => {
  const config = getConfigFromGlobalOrLocal();
  Object.assign(config[key], value);
};
var devConfig;
function setupDev(conf22) {
  devConfig = conf22;
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/matchMedia.mjs
var matchMedia = typeof window < "u" && window.matchMedia || matchMediaFallback;
function matchMediaFallback(_) {
  return {
    match: (a, b) => false,
    addListener() {
    },
    removeListener() {
    },
    matches: false
  };
}
function setupMatchMedia(_) {
}

// ../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.mjs
var import_react5 = __toESM(require_react(), 1);
var mediaState = (
  // development only safeguard
  true ? new Proxy({}, {
    get(target, key) {
      if (typeof key == "string" && key[0] === "$" && // dont error on $$typeof
      key[1] !== "$") throw new Error(`Access mediaState should not use "$": ${key}`);
      return Reflect.get(target, key);
    }
  }) : {}
);
var mediaQueryConfig = {};
var getMedia = () => mediaState;
var mediaKeys = /* @__PURE__ */ new Set();
var mediaKeyRegex = /\$(platform|theme|group)-/;
var isMediaKey = (key) => key[0] !== "$" ? false : !!(mediaKeys.has(key) || mediaKeyRegex.test(key));
var getMediaKey = (key) => {
  if (key[0] !== "$") return false;
  if (mediaKeys.has(key)) return true;
  const match = key.match(mediaKeyRegex);
  return match ? match[1] : false;
};
var initState;
var mediaKeysOrdered;
var getMediaKeyImportance = (key) => {
  if (key[0] === "$") throw new Error("use short key");
  return getConfig().settings.mediaPropOrder ? defaultMediaImportance : mediaKeysOrdered.indexOf(key) + 100;
};
var dispose = /* @__PURE__ */ new Set();
var mediaVersion = 0;
var configureMedia = (config) => {
  const {
    media
  } = config, mediaQueryDefaultActive = getSetting("mediaQueryDefaultActive");
  if (media) {
    mediaVersion++;
    for (const key in media) mediaState[key] = mediaQueryDefaultActive?.[key] || false, mediaKeys.add(`$${key}`);
    Object.assign(mediaQueryConfig, media), initState = {
      ...mediaState
    }, mediaKeysOrdered = Object.keys(media), setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach((cb) => cb()), dispose.clear();
}
var setupVersion = -1;
function setupMediaListeners() {
  if (!(isWeb && isServer) && !process.env.IS_STATIC && setupVersion !== mediaVersion) {
    setupVersion = mediaVersion, unlisten();
    for (const key in mediaQueryConfig) {
      let update = function() {
        const next = !!getMatch().matches;
        next !== mediaState[key] && (mediaState = {
          ...mediaState,
          [key]: next
        }, updateMediaListeners());
      };
      const str = mediaObjectToString(mediaQueryConfig[key], key), getMatch = () => matchMedia(str), match = getMatch();
      if (!match) throw new Error("âš ï¸ No match");
      match.addListener(update), dispose.add(() => {
        match.removeListener(update);
      }), update();
    }
  }
}
var listeners = /* @__PURE__ */ new Set();
function updateMediaListeners() {
  listeners.forEach((cb) => cb(mediaState));
}
var States = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, enabled, keys) {
  const cur = States.get(ref);
  (!cur || cur.enabled !== enabled || keys) && States.set(ref, {
    ...cur,
    enabled,
    keys
  });
}
function subscribe(subscriber) {
  return listeners.add(subscriber), () => {
    listeners.delete(subscriber);
  };
}
function useMedia(componentContext, debug) {
  const componentState = componentContext ? States.get(componentContext) : null, internalRef = (0, import_react5.useRef)(null);
  internalRef.current || (internalRef.current = {
    keys: /* @__PURE__ */ new Set(),
    lastState: mediaState
  }), internalRef.current.pendingState && (internalRef.current.lastState = internalRef.current.pendingState, internalRef.current.pendingState = void 0);
  const {
    keys
  } = internalRef.current;
  keys.size && keys.clear();
  const state = (0, import_react5.useSyncExternalStore)(subscribe, () => {
    const curKeys2 = componentState?.keys || keys, {
      lastState,
      pendingState
    } = internalRef.current;
    if (!curKeys2.size) return lastState;
    for (const key of curKeys2) if (mediaState[key] !== (pendingState || lastState)[key]) return debug && console.warn("useMedia() âœï¸", key, lastState[key], "=>", mediaState[key]), componentContext?.mediaEmit ? (componentContext.mediaEmit(mediaState), internalRef.current.pendingState = mediaState, lastState) : (internalRef.current.lastState = mediaState, mediaState);
    return lastState;
  }, getServerSnapshot);
  return new Proxy(state, {
    get(_, key) {
      return !disableMediaTouch && typeof key == "string" && keys.add(key), Reflect.get(state, key);
    }
  });
}
var getServerSnapshot = () => initState;
var disableMediaTouch = false;
function _disableMediaTouch(val) {
  disableMediaTouch = val;
}
function getMediaState(mediaGroups, layout) {
  disableMediaTouch = true;
  let res;
  try {
    res = Object.fromEntries([...mediaGroups].map((mediaKey) => [mediaKey, mediaKeyMatch(mediaKey, layout)]));
  } finally {
    disableMediaTouch = false;
  }
  return res;
}
var getMediaImportanceIfMoreImportant = (mediaKey, key, styleState, isSizeMedia) => {
  const importance = isSizeMedia && !getSetting("mediaPropOrder") ? getMediaKeyImportance(mediaKey) : defaultMediaImportance, usedKeys = styleState.usedKeys;
  return !usedKeys[key] || importance > usedKeys[key] ? importance : null;
};
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).toLowerCase();
}
var cache2 = /* @__PURE__ */ new WeakMap();
var cachedMediaKeyToQuery = {};
function mediaObjectToString(query, key) {
  if (typeof query == "string") return query;
  if (cache2.has(query)) return cache2.get(query);
  const res = Object.entries(query).map(([feature, value]) => (feature = camelToHyphen(feature), typeof value == "string" ? `(${feature}: ${value})` : (typeof value == "number" && /[height|width]$/.test(feature) && (value = `${value}px`), `(${feature}: ${value})`))).join(" and ");
  return key && (cachedMediaKeyToQuery[key] = res), cache2.set(query, res), res;
}
function mediaKeyMatch(key, dimensions) {
  const mediaQueries = mediaQueryConfig[key];
  return Object.keys(mediaQueries).every((query) => {
    const expectedVal = +mediaQueries[query], isMax = query.startsWith("max"), isWidth = query.endsWith("Width"), givenVal = dimensions[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
}

// ../../node_modules/@tamagui/simple-hash/dist/esm/index.mjs
var cache3 = /* @__PURE__ */ new Map();
var cacheSize = 0;
var simpleHash = (strIn, hashMin = 10) => {
  if (cache3.has(strIn)) return cache3.get(strIn);
  let str = strIn;
  str[0] === "v" && str.startsWith("var(") && (str = str.slice(6, str.length - 1));
  let hash = 0, valids = "", added = 0;
  const len = str.length;
  for (let i = 0; i < len; i++) {
    if (hashMin !== "strict" && added <= hashMin) {
      const char = str.charCodeAt(i);
      if (char === 46) {
        valids += "--";
        continue;
      }
      if (isValidCSSCharCode(char)) {
        added++, valids += str[i];
        continue;
      }
    }
    hash = hashChar(hash, str[i]);
  }
  const res = valids + (hash ? Math.abs(hash) : "");
  return cacheSize > 1e4 && (cache3.clear(), cacheSize = 0), cache3.set(strIn, res), cacheSize++, res;
};
var hashChar = (hash, c) => Math.imul(31, hash) + c.charCodeAt(0) | 0;
function isValidCSSCharCode(code) {
  return (
    // A-Z
    code >= 65 && code <= 90 || // a-z
    code >= 97 && code <= 122 || // _
    code === 95 || // -
    code === 45 || // 0-9
    code >= 48 && code <= 57
  );
}

// ../../node_modules/@tamagui/helpers/dist/esm/clamp.mjs
function clamp(value, [min, max]) {
  return Math.min(max, Math.max(min, value));
}

// ../../node_modules/@tamagui/helpers/dist/esm/composeEventHandlers.mjs
function composeEventHandlers(og, next, {
  checkDefaultPrevented = true
} = {}) {
  return !og || !next ? next || og || void 0 : (event) => {
    if (og?.(event), !event || !(checkDefaultPrevented && typeof event == "object" && "defaultPrevented" in event) || // @ts-ignore
    "defaultPrevented" in event && !event.defaultPrevented) return next?.(event);
  };
}

// ../../node_modules/@tamagui/helpers/dist/esm/types.mjs
var StyleObjectProperty = 0;
var StyleObjectValue = 1;
var StyleObjectIdentifier = 2;
var StyleObjectPseudo = 3;
var StyleObjectRules = 4;

// ../../node_modules/@tamagui/helpers/dist/esm/shouldRenderNativePlatform.mjs
var ALL_PLATFORMS = ["web", "android", "ios"];
function shouldRenderNativePlatform(nativeProp) {
  if (!nativeProp) return null;
  const userRequestedPlatforms = resolvePlatformNames(nativeProp);
  for (const platform of ALL_PLATFORMS) if (platform === currentPlatform && userRequestedPlatforms.has(platform)) return platform;
  return null;
}
function resolvePlatformNames(nativeProp) {
  const platforms = nativeProp === true ? ALL_PLATFORMS : nativeProp === false ? [] : Array.isArray(nativeProp) ? nativeProp : [nativeProp], set = new Set(platforms);
  return set.has("mobile") && (set.add("android"), set.add("ios"), set.delete("mobile")), set;
}

// ../../node_modules/@tamagui/helpers/dist/esm/validStyleProps.mjs
var textColors = {
  color: true,
  textDecorationColor: true,
  textShadowColor: true
};
var tokenCategories = {
  radius: {
    borderRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    // logical
    borderStartStartRadius: true,
    borderStartEndRadius: true,
    borderEndStartRadius: true,
    borderEndEndRadius: true
  },
  size: {
    width: true,
    height: true,
    minWidth: true,
    minHeight: true,
    maxWidth: true,
    maxHeight: true,
    blockSize: true,
    minBlockSize: true,
    maxBlockSize: true,
    inlineSize: true,
    minInlineSize: true,
    maxInlineSize: true
  },
  zIndex: {
    zIndex: true
  },
  color: {
    backgroundColor: true,
    borderColor: true,
    borderBlockStartColor: true,
    borderBlockEndColor: true,
    borderBlockColor: true,
    borderBottomColor: true,
    borderInlineColor: true,
    borderInlineStartColor: true,
    borderInlineEndColor: true,
    borderTopColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderEndColor: true,
    borderStartColor: true,
    shadowColor: true,
    ...textColors,
    outlineColor: true,
    caretColor: true
  }
};
var stylePropsUnitless = {
  WebkitLineClamp: true,
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  gridTemplateColumns: true,
  gridTemplateAreas: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  shadowOpacity: true
};
var stylePropsTransform = {
  x: true,
  y: true,
  scale: true,
  perspective: true,
  scaleX: true,
  scaleY: true,
  skewX: true,
  skewY: true,
  matrix: true,
  rotate: true,
  rotateY: true,
  rotateX: true,
  rotateZ: true
};
var stylePropsView = {
  backfaceVisibility: true,
  borderBottomEndRadius: true,
  borderBottomStartRadius: true,
  borderBottomWidth: true,
  borderLeftWidth: true,
  borderRightWidth: true,
  borderBlockWidth: true,
  borderBlockEndWidth: true,
  borderBlockStartWidth: true,
  borderInlineWidth: true,
  borderInlineEndWidth: true,
  borderInlineStartWidth: true,
  borderStyle: true,
  borderBlockStyle: true,
  borderBlockEndStyle: true,
  borderBlockStartStyle: true,
  borderInlineStyle: true,
  borderInlineEndStyle: true,
  borderInlineStartStyle: true,
  borderTopEndRadius: true,
  borderTopStartRadius: true,
  borderTopWidth: true,
  borderWidth: true,
  transform: true,
  transformOrigin: true,
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  borderEndWidth: true,
  borderStartWidth: true,
  bottom: true,
  display: true,
  end: true,
  flexBasis: true,
  flexDirection: true,
  flexWrap: true,
  gap: true,
  columnGap: true,
  rowGap: true,
  justifyContent: true,
  left: true,
  margin: true,
  marginBlock: true,
  marginBlockEnd: true,
  marginBlockStart: true,
  marginInline: true,
  marginInlineStart: true,
  marginInlineEnd: true,
  marginBottom: true,
  marginEnd: true,
  marginHorizontal: true,
  marginLeft: true,
  marginRight: true,
  marginStart: true,
  marginTop: true,
  marginVertical: true,
  overflow: true,
  padding: true,
  paddingBottom: true,
  paddingInline: true,
  paddingBlock: true,
  paddingBlockStart: true,
  paddingInlineEnd: true,
  paddingInlineStart: true,
  paddingEnd: true,
  paddingHorizontal: true,
  paddingLeft: true,
  paddingRight: true,
  paddingStart: true,
  paddingTop: true,
  paddingVertical: true,
  position: true,
  right: true,
  start: true,
  top: true,
  inset: true,
  insetBlock: true,
  insetBlockEnd: true,
  insetBlockStart: true,
  insetInline: true,
  insetInlineEnd: true,
  insetInlineStart: true,
  direction: true,
  shadowOffset: true,
  shadowRadius: true,
  ...tokenCategories.color,
  ...tokenCategories.radius,
  ...tokenCategories.size,
  ...tokenCategories.radius,
  ...stylePropsTransform,
  ...stylePropsUnitless,
  boxShadow: true,
  filter: true,
  // RN 0.77+ style props (set REACT_NATIVE_PRE_77=1 for older RN)
  ...!process.env.REACT_NATIVE_PRE_77 && {
    boxSizing: true,
    mixBlendMode: true,
    outlineColor: true,
    outlineSpread: true,
    outlineStyle: true,
    outlineWidth: true
  },
  // RN doesn't support specific border styles per-edge
  transition: true,
  textWrap: true,
  backdropFilter: true,
  WebkitBackdropFilter: true,
  background: true,
  backgroundAttachment: true,
  backgroundBlendMode: true,
  backgroundClip: true,
  backgroundColor: true,
  backgroundImage: true,
  backgroundOrigin: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundSize: true,
  borderBottomStyle: true,
  borderImage: true,
  borderLeftStyle: true,
  borderRightStyle: true,
  borderTopStyle: true,
  caretColor: true,
  clipPath: true,
  contain: true,
  containerType: true,
  content: true,
  cursor: true,
  float: true,
  mask: true,
  maskBorder: true,
  maskBorderMode: true,
  maskBorderOutset: true,
  maskBorderRepeat: true,
  maskBorderSlice: true,
  maskBorderSource: true,
  maskBorderWidth: true,
  maskClip: true,
  maskComposite: true,
  maskImage: true,
  maskMode: true,
  maskOrigin: true,
  maskPosition: true,
  maskRepeat: true,
  maskSize: true,
  maskType: true,
  objectFit: true,
  objectPosition: true,
  outlineOffset: true,
  overflowBlock: true,
  overflowInline: true,
  overflowX: true,
  overflowY: true,
  pointerEvents: true,
  scrollbarWidth: true,
  textEmphasis: true,
  touchAction: true,
  transformStyle: true,
  userSelect: true,
  willChange: true,
  ...isAndroid ? {
    elevationAndroid: true
  } : {}
};
var stylePropsFont = {
  fontFamily: true,
  fontSize: true,
  fontStyle: true,
  fontWeight: true,
  fontVariant: true,
  letterSpacing: true,
  lineHeight: true,
  textTransform: true
};
var stylePropsTextOnly = {
  ...stylePropsFont,
  textAlign: true,
  textDecorationLine: true,
  textDecorationStyle: true,
  ...textColors,
  textShadowOffset: true,
  textShadowRadius: true,
  userSelect: true,
  selectable: true,
  verticalAlign: true,
  whiteSpace: true,
  wordWrap: true,
  textOverflow: true,
  textDecorationDistance: true,
  cursor: true,
  WebkitLineClamp: true,
  WebkitBoxOrient: true
};
var stylePropsText = {
  ...stylePropsView,
  ...stylePropsTextOnly
};
var stylePropsAll = stylePropsText;
var validPseudoKeys = {
  enterStyle: true,
  exitStyle: true,
  hoverStyle: true,
  pressStyle: true,
  focusStyle: true,
  disabledStyle: true,
  focusWithinStyle: true,
  focusVisibleStyle: true
};
var validStyles = stylePropsView;

// ../../node_modules/@tamagui/helpers/dist/esm/withStaticProperties.mjs
var import_react6 = __toESM(require_react(), 1);
var Decorated = /* @__PURE__ */ Symbol();
var withStaticProperties = (component, staticProps) => {
  const next = (() => {
    if (component[Decorated]) {
      const _ = import_react6.default.forwardRef((props, ref) => import_react6.default.createElement(component, {
        ...props,
        ref
      }));
      for (const key in component) {
        const v = component[key];
        _[key] = v && typeof v == "object" ? {
          ...v
        } : v;
      }
    }
    return component;
  })();
  return Object.assign(next, staticProps), next[Decorated] = true, next;
};

// ../../node_modules/@tamagui/helpers/dist/esm/index.mjs
var esm_exports = {};
__export(esm_exports, {
  StyleObjectIdentifier: () => StyleObjectIdentifier,
  StyleObjectProperty: () => StyleObjectProperty,
  StyleObjectPseudo: () => StyleObjectPseudo,
  StyleObjectRules: () => StyleObjectRules,
  StyleObjectValue: () => StyleObjectValue,
  clamp: () => clamp,
  composeEventHandlers: () => composeEventHandlers,
  shouldRenderNativePlatform: () => shouldRenderNativePlatform,
  simpleHash: () => simpleHash,
  stylePropsAll: () => stylePropsAll,
  stylePropsText: () => stylePropsText,
  stylePropsTextOnly: () => stylePropsTextOnly,
  stylePropsTransform: () => stylePropsTransform,
  stylePropsUnitless: () => stylePropsUnitless,
  stylePropsView: () => stylePropsView,
  tokenCategories: () => tokenCategories,
  validPseudoKeys: () => validPseudoKeys,
  validStyles: () => validStyles,
  withStaticProperties: () => withStaticProperties
});

// ../../node_modules/@tamagui/web/dist/esm/createVariable.mjs
function constructCSSVariableName(name) {
  return `var(--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${name})`;
}
var createVariable = (props, skipHash = false) => {
  if (!skipHash && isVariable(props)) return props;
  const {
    key,
    name,
    val
  } = props;
  return {
    isVar: true,
    key,
    name: skipHash ? name : simpleHash(name, 40),
    val,
    variable: isWeb ? skipHash ? constructCSSVariableName(name) : createCSSVariable(name) : ""
  };
};
function variableToString(vrble, getValue = false) {
  return isVariable(vrble) ? !getValue && isWeb && vrble.variable ? vrble.variable : `${vrble.val}` : `${vrble || ""}`;
}
function isVariable(v) {
  return v && typeof v == "object" && "isVar" in v;
}
function getVariable(nameOrVariable, group = "size") {
  if (nameOrVariable?.dynamic) return nameOrVariable;
  if (setDidGetVariableValue(true), isVariable(nameOrVariable)) return variableToString(nameOrVariable);
  const tokens = getConfig().tokensParsed;
  return variableToString(tokens[group]?.[nameOrVariable] ?? nameOrVariable);
}
var accessed = false;
var setDidGetVariableValue = (val) => accessed = val;
var didGetVariableValue = () => accessed;
function getVariableValue(v, group) {
  if (isVariable(v)) return setDidGetVariableValue(true), v.val;
  if (group) {
    const token = getConfig().tokensParsed[group]?.[v];
    if (token) return setDidGetVariableValue(true), token.val;
  }
  return v;
}
function getVariableName(v) {
  return isVariable(v) ? v.name : v;
}
var createCSSVariable = (nameProp, includeVar = true) => {
  if (!nameProp || typeof nameProp != "string") throw new Error(`createCSSVariable expected string, got: ${nameProp}`);
  const name = simpleHash(nameProp, 60);
  return includeVar ? constructCSSVariableName(name) : name;
};

// ../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.mjs
var import_react8 = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/web/dist/esm/hooks/getThemeProxied.mjs
var cache4 = /* @__PURE__ */ new Map();
var curKeys;
var curProps;
var curState;
var emptyObject = {};
function getThemeProxied(_props, _state, _keys) {
  if (!_state?.theme) return emptyObject;
  if (curKeys = _keys, curProps = _props, curState = _state, cache4.has(curState.theme)) return cache4.get(curState.theme);
  const config = getConfig();
  function track(key) {
    curKeys && (curKeys.current || (curKeys.current = /* @__PURE__ */ new Set()), curKeys.current.add(key), curProps.debug && console.info(` ðŸŽ¨ useTheme() tracking new key: ${key}`, curKeys));
  }
  const proxied = Object.fromEntries(Object.entries(_state.theme).flatMap(([key, value]) => {
    const proxied2 = {
      ...value,
      get val() {
        return globalThis.tamaguiAvoidTracking || track(key), value.val;
      },
      get(platform) {
        if (!curState) return;
        const outVal = getVariable(value), {
          name,
          scheme,
          inverses
        } = curState;
        return outVal;
      }
    };
    return [[key, proxied2], [`$${key}`, proxied2]];
  }));
  return cache4.set(_state.theme, proxied), proxied;
}

// ../../node_modules/@tamagui/web/dist/esm/hooks/useThemeState.mjs
var import_react7 = __toESM(require_react(), 1);
var ThemeStateContext = (0, import_react7.createContext)("");
var allListeners = /* @__PURE__ */ new Map();
var listenersByParent = {};
var HasRenderedOnce = /* @__PURE__ */ new WeakMap();
var HadTheme = /* @__PURE__ */ new WeakMap();
var PendingUpdate = /* @__PURE__ */ new Map();
var states = /* @__PURE__ */ new Map();
var localStates = /* @__PURE__ */ new Map();
var shouldForce = false;
var forceUpdateThemes = () => {
  cacheVersion++, shouldForce = true, allListeners.forEach((cb) => cb());
};
var getThemeState = (id) => states.get(id);
var cacheVersion = 0;
var themes = null;
var rootThemeState = null;
var useThemeState = (props, isRoot = false, keys) => {
  const {
    disable
  } = props, parentId = (0, import_react7.useContext)(ThemeStateContext);
  if (!parentId && !isRoot) throw new Error(MISSING_THEME_MESSAGE);
  if (disable) return states.get(parentId) || {
    id: "",
    name: "light",
    theme: getConfig().themes.light,
    inverses: 0
  };
  const id = (0, import_react7.useId)(), subscribe3 = (0, import_react7.useCallback)((cb) => (listenersByParent[parentId] ||= /* @__PURE__ */ new Set(), listenersByParent[parentId].add(id), allListeners.set(id, () => {
    PendingUpdate.set(id, shouldForce ? "force" : true), cb();
  }), () => {
    allListeners.delete(id), listenersByParent[parentId].delete(id), localStates.delete(id), states.delete(id), PendingUpdate.delete(id);
  }), [id, parentId]), propsKey = getPropsKey(props), getSnapshot = () => {
    let local = localStates.get(id);
    const needsUpdate = props.passThrough ? false : isRoot || props.name === "light" || props.name === "dark" || props.name === null ? true : HasRenderedOnce.get(keys) ? keys?.current?.size ? true : props.needsUpdate?.() : true, [rerender, next] = getNextState(local, props, propsKey, isRoot, id, parentId, needsUpdate, PendingUpdate.get(id));
    return PendingUpdate.delete(id), (!local || rerender) && (local = {
      ...next
    }, localStates.set(id, local)), props.debug === "verbose" && (console.groupCollapsed(` ${id} getSnapshot ${rerender}`, local.name, ">", next.name), console.info({
      props,
      propsKey,
      isRoot,
      parentId,
      local,
      next,
      needsUpdate
    }), console.groupEnd()), Object.assign(local, next), local.id = id, states.set(id, next), local;
  };
  globalThis.time && globalThis.time`theme-prep-uses`;
  const state = (0, import_react7.useSyncExternalStore)(subscribe3, getSnapshot, getSnapshot);
  return useIsomorphicLayoutEffect(() => {
    if (!HasRenderedOnce.get(keys)) {
      HasRenderedOnce.set(keys, true);
      return;
    }
    if (!propsKey) {
      HadTheme.get(keys) && scheduleUpdate(id), HadTheme.set(keys, false);
      return;
    }
    props.debug === "verbose" && console.warn(` Â· useTheme(${id}) scheduleUpdate`, propsKey, states.get(id)?.name), scheduleUpdate(id), HadTheme.set(keys, true);
  }, [keys, propsKey]), state;
};
var getNextState = (lastState, props, propsKey, isRoot = false, id, parentId, needsUpdate, pendingUpdate) => {
  const {
    debug
  } = props, parentState = states.get(parentId);
  if (props.passThrough) return [false, lastState || parentState || {
    name: ""
  }];
  themes || (themes = getConfig().themes);
  const name = !propsKey && (!lastState || !lastState?.isNew) ? null : getNewThemeName(parentState?.name, props, pendingUpdate === "force" ? true : !!needsUpdate), isSameAsParent = parentState && (!name || name === parentState.name), shouldRerender = !!(needsUpdate && (pendingUpdate || lastState?.name !== parentState?.name));
  if (debug === "verbose") {
    const message = ` Â· useTheme(${id}) getNextState => ${name} needsUpdate ${needsUpdate} shouldRerender ${shouldRerender}`;
    console.groupCollapsed(message), console.trace({
      name,
      lastState,
      parentState,
      props,
      propsKey,
      id,
      isSameAsParent
    }), console.groupEnd();
  }
  if (isSameAsParent) return [shouldRerender, {
    ...parentState,
    isNew: false
  }];
  if (!name) {
    const next = lastState ?? parentState;
    if (!next) throw new Error(MISSING_THEME_MESSAGE);
    return shouldRerender ? [true, {
      ...parentState || lastState
    }] : [false, next];
  }
  const scheme = getScheme(name), parentInverses = parentState?.inverses ?? 0, isInverse = parentState && scheme !== parentState.scheme, inverses = parentInverses + (isInverse ? 1 : 0), nextState = {
    id,
    name,
    theme: themes[name],
    scheme,
    parentId,
    parentName: parentState?.name,
    inverses,
    isInverse,
    isNew: true
  };
  if (isRoot && (rootThemeState = nextState), pendingUpdate !== "force" && lastState && lastState.name === name) return [false, nextState];
  const shouldAvoidRerender = pendingUpdate !== "force" && lastState && !needsUpdate && nextState.name === lastState.name;
  return debug === "verbose" && (console.groupCollapsed(` Â· useTheme(${id}) â­ï¸ ${name} shouldAvoidRerender: ${shouldAvoidRerender}`), console.info({
    lastState,
    needsUpdate,
    nextState,
    pendingUpdate
  }), console.groupEnd()), shouldAvoidRerender ? [false, nextState] : [true, nextState];
};
function scheduleUpdate(id) {
  const queue = [id], visited = /* @__PURE__ */ new Set();
  for (; queue.length; ) {
    const parent = queue.shift(), children = listenersByParent[parent];
    if (children) for (const childId of children) visited.has(childId) || (visited.add(childId), queue.push(childId));
  }
  visited.forEach((childId) => {
    allListeners.get(childId)?.();
  });
}
var validSchemes = {
  light: "light",
  dark: "dark"
};
function getScheme(name) {
  return validSchemes[name.split("_")[0]];
}
function getNewThemeName(parentName = "", {
  name,
  reset,
  componentName,
  inverse,
  debug
}, forceUpdate = false) {
  if (name && reset) throw new Error(false ? "âŒ004" : "Cannot reset and set a new name at the same time.");
  const {
    themes: themes2
  } = getConfig();
  if (reset) {
    if (parentName === "light" || parentName === "dark") return parentName === "light" ? "dark" : "light";
    const lastPartIndex = parentName.lastIndexOf("_"), name2 = lastPartIndex <= 0 ? parentName : parentName.slice(lastPartIndex), scheme = parentName.slice(0, lastPartIndex);
    return themes2[name2] ? name2 : scheme;
  }
  const parentParts = parentName.split("_"), lastName = parentParts[parentParts.length - 1];
  lastName && lastName[0].toLowerCase() !== lastName[0] && parentParts.pop();
  const subNames = [name && componentName ? `${name}_${componentName}` : void 0, name, componentName].filter(Boolean);
  let found = null;
  if (name) {
    const nameHasScheme = getScheme(name);
    if (nameHasScheme) {
      for (const subName of subNames) if (subName in themes2) {
        found = subName;
        break;
      }
    }
    if (!found && !nameHasScheme && getScheme(parentName)) {
      const potentialBases = [];
      for (let i = parentParts.length; i >= 1; i--) potentialBases.push(parentParts.slice(0, i).join("_"));
      outer: for (const base of potentialBases) {
        const candidates = [componentName ? `${base}_${name}_${componentName}` : void 0, `${base}_${name}`].filter(Boolean);
        for (const potential of candidates) if (potential in themes2) {
          found = potential;
          break outer;
        }
      }
    }
  }
  if (!found) if (!name && componentName) {
    const potential = `${parentParts.join("_")}_${componentName}`;
    potential in themes2 && (found = potential);
  } else {
    const max = parentParts.length;
    for (let i = 0; i <= max; i++) {
      const base = (i === 0 ? parentParts : parentParts.slice(0, -i)).join("_");
      for (const subName of subNames) {
        const potential = base ? `${base}_${subName}` : subName;
        if (potential in themes2) {
          found = potential;
          break;
        }
      }
      if (found) break;
    }
  }
  if (inverse) {
    found ||= parentName;
    const scheme = found.split("_")[0];
    found = found.replace(new RegExp(`^${scheme}`), scheme === "light" ? "dark" : "light");
  }
  return !forceUpdate && found === parentName && // if its a scheme only sub-theme, we always consider it "new" because it likely inverses
  // and we want to avoid reparenting
  !validSchemes[found] ? null : found;
}
var getPropsKey = ({
  name,
  reset,
  inverse,
  forceClassName,
  componentName
}) => `${name || ""}${inverse || ""}${reset || ""}${forceClassName || ""}${componentName || ""}`;
var hasThemeUpdatingProps = (props) => "inverse" in props || "name" in props || "reset" in props || "forceClassName" in props;

// ../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.mjs
var useTheme = (props = {}) => {
  const [theme] = useThemeWithState(props);
  return theme;
};
var useThemeWithState = (props, isRoot = false) => {
  const keys = (0, import_react8.useRef)(null), themeState = useThemeState(props, isRoot, keys);
  return !props.passThrough && !themeState?.theme && process.env.TAMAGUI_DISABLE_NO_THEME_WARNING !== "1" && console.error(`[tamagui] No theme found, this could be due to an invalid theme name (given theme props ${JSON.stringify(props)}).

If this is intended and you are using Tamagui without any themes, you can disable this warning by setting the environment variable TAMAGUI_DISABLE_NO_THEME_WARNING=1`), [props.passThrough ? {} : getThemeProxied(props, themeState, keys), themeState];
};

// ../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs
var React4 = __toESM(require_react(), 1);
function setRef(ref, value) {
  typeof ref == "function" ? ref(value) : ref && (ref.current = value);
}
function composeRefs(...refs) {
  return (node2) => refs.forEach((ref) => setRef(ref, node2));
}
function useComposedRefs(...refs) {
  return React4.useCallback(composeRefs(...refs), refs);
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/defaultOffset.mjs
var defaultOffset = {
  height: 0,
  width: 0
};

// ../../node_modules/@tamagui/normalize-css-color/dist/esm/index.mjs
var normalizeColor = __toESM(require_normalize_color(), 1);
var norm = normalizeColor.default || normalizeColor;
var normalizeCSSColor = norm;
function rgba(colorInt) {
  const r = Math.round((colorInt & 4278190080) >>> 24), g = Math.round((colorInt & 16711680) >>> 16), b = Math.round((colorInt & 65280) >>> 8), a = ((colorInt & 255) >>> 0) / 255;
  return {
    r,
    g,
    b,
    a
  };
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/normalizeColor.mjs
var normalizeColor2 = (color, opacity) => {
  if (color) {
    if (typeof color != "string" || color[0] === "$") return color;
    if (color.startsWith("var(")) {
      if (typeof opacity == "number" && opacity < 1) return `color-mix(in srgb, ${color} ${opacity * 100}%, transparent)`;
    } else {
      const rgba3 = getRgba(color);
      if (rgba3) {
        const colors = `${rgba3.r},${rgba3.g},${rgba3.b}`;
        return opacity === 1 ? `rgb(${colors})` : `rgba(${colors},${opacity ?? rgba3.a ?? 1})`;
      }
    }
    return color;
  }
};
var getRgba = (color) => {
  if (typeof color != "string") return;
  const colorNum = normalizeCSSColor(color);
  if (colorNum != null) return rgba(colorNum);
};

// ../../node_modules/@tamagui/web/dist/esm/helpers/normalizeValueWithProperty.mjs
var stylePropsAllPlusTransforms = {
  ...stylePropsAll,
  translateX: true,
  translateY: true
};
function normalizeValueWithProperty(value, property = "") {
  if (!isWeb || stylePropsUnitless[property] || property && !stylePropsAllPlusTransforms[property] || typeof value == "boolean") return value;
  let res = value;
  return value && typeof value == "object" ? value : (typeof value == "number" ? res = `${value}px` : property && (res = `${res}`), res);
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/transformsToString.mjs
function transformsToString(transforms) {
  return transforms.map(
    // { scale: 2 } => 'scale(2)'
    // { translateX: 20 } => 'translateX(20px)'
    // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
    // { perspective: 1000 } => perspective(1000px)
    (transform) => {
      const type = Object.keys(transform)[0], value = transform[type];
      return type === "matrix" || type === "matrix3d" ? `${type}(${value.join(",")})` : `${type}(${normalizeValueWithProperty(value, type)})`;
    }
  ).join(" ");
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/getCSSStylesAtomic.mjs
function getCSSStylesAtomic(style) {
  styleToCSS(style);
  const out = [];
  for (const key in style) {
    if (key === "$$css") continue;
    const val = style[key];
    if (key in pseudoDescriptors) val && out.push(...getStyleAtomic(val, pseudoDescriptors[key]));
    else if (isMediaKey(key)) for (const subKey in val) {
      const so = getStyleObject(val, subKey);
      so && (so[0] = key, out.push(so));
    }
    else {
      const so = getStyleObject(style, key);
      so && out.push(so);
    }
  }
  return out;
}
var getStyleAtomic = (style, pseudo) => {
  styleToCSS(style);
  const out = [];
  for (const key in style) {
    const so = getStyleObject(style, key, pseudo);
    so && out.push(so);
  }
  return out;
};
var conf2 = null;
var getStyleObject = (style, key, pseudo) => {
  let val = style[key];
  if (val == null) return;
  key === "transform" && Array.isArray(style.transform) && (val = transformsToString(val));
  const value = normalizeValueWithProperty(val, key), hash = simpleHash(typeof value == "string" ? value : `${value}`), pseudoPrefix = pseudo ? `0${pseudo.name}-` : "";
  conf2 ||= getConfigMaybe();
  const identifier = `_${conf2?.inverseShorthands[key] || key}-${pseudoPrefix}${hash}`, rules = createAtomicRules(identifier, key, value, pseudo);
  return [
    // array for performance
    key,
    value,
    identifier,
    pseudo?.name,
    rules
  ];
};
function styleToCSS(style) {
  const {
    shadowOffset,
    shadowRadius,
    shadowColor,
    shadowOpacity
  } = style;
  if (shadowRadius != null || shadowColor || shadowOffset != null || shadowOpacity != null) {
    const offset = shadowOffset || defaultOffset, width = normalizeValueWithProperty(offset.width), height = normalizeValueWithProperty(offset.height), radius = normalizeValueWithProperty(shadowRadius), color = normalizeColor2(shadowColor, shadowOpacity);
    if (color) {
      const shadow = `${width} ${height} ${radius} ${color}`;
      style.boxShadow = style.boxShadow ? `${style.boxShadow}, ${shadow}` : shadow;
    }
    delete style.shadowOffset, delete style.shadowRadius, delete style.shadowColor, delete style.shadowOpacity;
  }
  const {
    textShadowColor,
    textShadowOffset,
    textShadowRadius
  } = style;
  if (textShadowColor || textShadowOffset || textShadowRadius) {
    const {
      height,
      width
    } = textShadowOffset || defaultOffset, radius = textShadowRadius || 0, color = normalizeValueWithProperty(textShadowColor, "textShadowColor");
    if (color && (height !== 0 || width !== 0 || radius !== 0)) {
      const blurRadius = normalizeValueWithProperty(radius), offsetX = normalizeValueWithProperty(width), offsetY = normalizeValueWithProperty(height);
      style.textShadow = `${offsetX} ${offsetY} ${blurRadius} ${color}`;
    }
    delete style.textShadowColor, delete style.textShadowOffset, delete style.textShadowRadius;
  }
}
function createDeclarationBlock(style, important = false) {
  let next = "";
  for (const [key, value] of style) next += `${hyphenateStyleName(key)}:${value}${important ? " !important" : ""};`;
  return `{${next}}`;
}
var hcache = {};
var toHyphenLower = (match) => `-${match.toLowerCase()}`;
var hyphenateStyleName = (key) => {
  if (key in hcache) return hcache[key];
  const val = key.replace(/[A-Z]/g, toHyphenLower);
  return hcache[key] = val, val;
};
var selectorPriority = (() => {
  const res = {};
  for (const key in pseudoDescriptors) {
    const pseudo = pseudoDescriptors[key];
    res[pseudo.name] = `${[...Array(pseudo.priority)].map(() => ":root").join("")} `;
  }
  return res;
})();
function createAtomicRules(identifier, property, value, pseudo) {
  const pseudoIdPostfix = pseudo ? pseudo.name === "disabled" ? "[aria-disabled]" : `:${pseudo.name}` : "", pseudoSelector = pseudo?.selector;
  let selector = pseudo ? pseudoSelector ? `${pseudoSelector} .${identifier}` : `${selectorPriority[pseudo.name]} .${identifier}${pseudoIdPostfix}` : `:root .${identifier}`;
  pseudoSelector === pseudoDescriptors.enterStyle.selector && (selector = `${selector}, .${identifier}${pseudoSelector}`);
  const important = !!pseudo;
  let rules = [];
  switch (property) {
    // Equivalent to using '::placeholder'
    case "placeholderTextColor": {
      const block = createDeclarationBlock([["color", value], ["opacity", 1]], important);
      rules.push(`${selector}::placeholder${block}`);
      break;
    }
    // all webkit prefixed rules
    case "backgroundClip":
    case "userSelect": {
      const webkitProperty = `Webkit${`${property[0].toUpperCase()}${property.slice(1)}`}`, block = createDeclarationBlock([[property, value], [webkitProperty, value]], important);
      rules.push(`${selector}${block}`);
      break;
    }
    // Polyfill for additional 'pointer-events' values
    case "pointerEvents": {
      let finalValue = value;
      value === "auto" || value === "box-only" ? (finalValue = "auto", value === "box-only" && rules.push(`${selector}>*${boxOnly}`)) : (value === "none" || value === "box-none") && (finalValue = "none", value === "box-none" && rules.push(`${selector}>*${boxNone}`));
      const block = createDeclarationBlock([["pointerEvents", finalValue]], true);
      rules.push(`${selector}${block}`);
      break;
    }
    default: {
      const block = createDeclarationBlock([[property, value]], important);
      rules.push(`${selector}${block}`);
      break;
    }
  }
  return pseudo?.name === "hover" && (rules = rules.map((r) => `@media (hover) {${r}}`)), rules;
}
var boxNone = createDeclarationBlock([["pointerEvents", "auto"]], true);
var boxOnly = createDeclarationBlock([["pointerEvents", "none"]], true);

// ../../node_modules/@tamagui/use-did-finish-ssr/dist/esm/ClientOnly.mjs
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var ClientOnlyContext = (0, import_react9.createContext)(false);
var ClientOnly = ({
  children,
  enabled
}) => {
  const existingValue = (0, import_react9.useContext)(ClientOnlyContext);
  return (0, import_jsx_runtime2.jsx)(ClientOnlyContext.Provider, {
    value: enabled ?? existingValue,
    children
  });
};

// ../../node_modules/@tamagui/use-did-finish-ssr/dist/esm/index.mjs
var React5 = __toESM(require_react(), 1);
var useIsClientOnly = () => React5.useContext(ClientOnlyContext);
function useDidFinishSSR() {
  return React5.useContext(ClientOnlyContext) ? true : React5.useSyncExternalStore(subscribe2, () => true, () => false);
}
var subscribe2 = () => () => {
};

// ../../node_modules/@tamagui/web/dist/esm/views/Theme.mjs
var import_react11 = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/web/dist/esm/views/ThemeDebug.mjs
var import_react10 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var node;
function ThemeDebug({
  themeState,
  themeProps,
  children
}) {
  if (true) {
    const isHydrated = useDidFinishSSR();
    if (typeof document < "u" && (node || (node = document.createElement("div"), node.style.height = "200px", node.style.overflowY = "scroll", node.style.position = "fixed", node.style.zIndex = 1e7, node.style.bottom = "30px", node.style.left = "30px", node.style.right = "30px", node.style.display = "flex", node.style.border = "1px solid #888", node.style.flexDirection = "row", node.style.background = "var(--background)")), (0, import_react10.useEffect)(() => {
      document.body.appendChild(node);
    }, []), themeProps["disable-child-theme"] || !isHydrated) return children;
    const parentState = themeState.parentId ? getThemeState(themeState.parentId) : null;
    return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, {
      children: [(0, import_react_dom.createPortal)((0, import_jsx_runtime3.jsxs)("code", {
        style: {
          whiteSpace: "pre",
          maxWidth: 250,
          overflow: "auto",
          padding: 5
        },
        children: ["<Theme ", themeState.id, " />Â ", JSON.stringify({
          name: themeState.name,
          color1: themeState.theme.color1.val,
          parentId: themeState.parentId,
          inverses: themeState.inverses,
          isNew: themeState.isNew,
          themeProps: {
            name: themeProps.name,
            componentName: themeProps.componentName,
            reset: themeProps.reset,
            inverse: themeProps.inverse
          },
          parentState: {
            name: parentState?.name,
            isNew: parentState?.isNew
          }
        }, null, 2)]
      }), node), (0, import_jsx_runtime3.jsx)("div", {
        style: {
          color: "red"
        },
        children: themeState.id
      }), children]
    });
  }
  return children;
}
ThemeDebug.displayName = "ThemeDebug";

// ../../node_modules/@tamagui/web/dist/esm/views/Theme.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var Theme = (0, import_react11.forwardRef)(function(props, ref) {
  if (props.disable) return props.children;
  const {
    passThrough
  } = props, isRoot = !!props._isRoot, [_, themeState] = useThemeWithState(props, isRoot);
  let finalChildren = props["disable-child-theme"] ? import_react11.Children.map(props.children, (child) => passThrough ? child : (0, import_react11.cloneElement)(child, {
    "data-disable-theme": true
  })) : props.children;
  if (ref) try {
    import_react11.default.Children.only(finalChildren), finalChildren = (0, import_react11.cloneElement)(finalChildren, {
      ref
    });
  } catch {
  }
  const stateRef = (0, import_react11.useRef)({
    hasEverThemed: false
  });
  return getThemedChildren(themeState, finalChildren, props, isRoot, stateRef, passThrough);
});
Theme.avoidForwardRef = true;
function getThemedChildren(themeState, children, props, isRoot = false, stateRef, passThrough = false) {
  const {
    shallow,
    forceClassName
  } = props, state = stateRef.current;
  let shouldRenderChildrenWithTheme = state.hasEverThemed || themeState.isNew || isRoot || hasThemeUpdatingProps(props);
  if (props.debug === "visualize" && (children = (0, import_jsx_runtime4.jsx)(ThemeDebug, {
    themeState,
    themeProps: props,
    children
  })), !shouldRenderChildrenWithTheme) return children;
  children = (0, import_jsx_runtime4.jsx)(ThemeStateContext.Provider, {
    value: themeState.id,
    children
  });
  const {
    isInverse,
    name
  } = themeState, requiresExtraWrapper = isInverse || forceClassName;
  if (state.hasEverThemed || (state.hasEverThemed = true), (requiresExtraWrapper || // if the theme is exactly dark or light, its likely to change between dark/light
  // and that would require wrapping which would re-parent, so to avoid re-parenting do this
  themeState.name === "dark" || themeState.name === "light") && (state.hasEverThemed = "wrapped"), shallow && themeState.parentId) {
    const parentState = getThemeState(themeState.isNew ? themeState.id : themeState.parentId);
    if (!parentState) throw new Error("â€¼ï¸010");
    children = import_react11.Children.toArray(children).map((child) => (0, import_react11.isValidElement)(child) ? passThrough ? child : (0, import_react11.cloneElement)(child, void 0, (0, import_jsx_runtime4.jsx)(Theme, {
      name: parentState.name,
      children: child.props.children
    })) : child);
  }
  if (!passThrough && props.debug && console.warn(" getThemedChildren", {
    requiresExtraWrapper,
    forceClassName,
    themeState,
    state,
    themeSpanProps: getThemeClassNameAndColor(themeState, props, isRoot)
  }), forceClassName === false) return children;
  if (isWeb) {
    const baseStyle = props.contain ? inertContainedStyle : inertStyle, {
      className = "",
      color
    } = passThrough ? {} : getThemeClassNameAndColor(themeState, props, isRoot);
    if (children = (0, import_jsx_runtime4.jsx)("span", {
      className: `${className} is_Theme`,
      style: passThrough ? baseStyle : {
        color,
        ...baseStyle
      },
      children
    }), state.hasEverThemed === "wrapped") {
      const className2 = !passThrough && requiresExtraWrapper ? `${isInverse ? name.startsWith("light") ? "t_light is_inversed" : name.startsWith("dark") ? "t_dark is_inversed" : "" : ""} ` : "";
      children = (0, import_jsx_runtime4.jsx)("span", {
        style: baseStyle,
        className: className2,
        children
      });
    }
    return children;
  }
  return children;
}
var inertStyle = {
  display: "contents"
};
var inertContainedStyle = {
  display: "contents",
  contain: "strict"
};
var empty = {
  className: "",
  color: void 0
};
function getThemeClassNameAndColor(themeState, props, isRoot = false) {
  if (!themeState.isNew && !props.forceClassName) return empty;
  const themeColor = themeState?.theme && themeState.isNew ? variableToString(themeState.theme.color) : "", maxInverses = getSetting("maxDarkLightNesting") || 3, themeClassName = themeState.inverses >= maxInverses ? themeState.name : themeState.name.replace(schemePrefix, ""), themeNameParts = themeClassName.split("_");
  let themeClasses = `t_${themeClassName}`;
  if (themeNameParts.length > 1) {
    const hierarchyClasses = [];
    for (let i = 1; i <= themeNameParts.length; i++) hierarchyClasses.push(`t_${themeNameParts.slice(0, i).join("_")}`);
    themeClasses = hierarchyClasses.join(" ");
  }
  const className = `${isRoot ? "" : "t_sub_theme"} ${themeClasses}`;
  return {
    color: themeColor,
    className
  };
}
var schemePrefix = /^(dark|light)_/;

// ../../node_modules/@tamagui/web/dist/esm/helpers/themeable.mjs
var import_react12 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function themeable(Component, staticConfig, optimize = false) {
  const withTheme = import_react12.default.forwardRef(function(props, ref) {
    const {
      themeInverse,
      theme,
      componentName,
      themeReset,
      ...rest
    } = props;
    let overriddenContextProps;
    const context = staticConfig?.context;
    if (context) for (const key in context.props) {
      const val = props[key];
      val !== void 0 && (overriddenContextProps ||= {}, overriddenContextProps[key] = val);
    }
    const element = (
      // @ts-expect-error its ok
      (0, import_jsx_runtime5.jsx)(Component, {
        ref,
        ...rest,
        "data-disable-theme": true
      })
    );
    let filteredProps = null;
    const compName = componentName || staticConfig?.componentName;
    if (compName && (filteredProps ||= {}, filteredProps.componentName = compName), "debug" in props && (filteredProps ||= {}, filteredProps.debug = props.debug), "theme" in props && (filteredProps ||= {}, filteredProps.name = props.theme), "themeInverse" in props && (filteredProps ||= {}, filteredProps.inverse = props.themeInverse), "themeReset" in props && (filteredProps ||= {}, filteredProps.reset = themeReset), optimize && !filteredProps) return element;
    let contents = (0, import_jsx_runtime5.jsx)(Theme, {
      "disable-child-theme": true,
      ...filteredProps,
      children: element
    });
    if (context) {
      const Provider = context.Provider, contextValue = import_react12.default.useContext(context);
      contents = (0, import_jsx_runtime5.jsx)(Provider, {
        ...contextValue,
        ...overriddenContextProps,
        children: contents
      });
    }
    return contents;
  });
  return withTheme.displayName = `Themed(${Component?.displayName || Component?.name || "Anonymous"})`, withTheme;
}

// ../../node_modules/@tamagui/is-equal-shallow/dist/esm/index.mjs
var import_react13 = __toESM(require_react(), 1);
function useCreateShallowSetState(setter, debug) {
  return (0, import_react13.useCallback)((stateOrGetState) => {
    setter((prev) => {
      const next = typeof stateOrGetState == "function" ? stateOrGetState(prev) : stateOrGetState, update = mergeIfNotShallowEqual(prev, next);
      if (debug && update !== prev && (console.groupCollapsed("setStateShallow CHANGE", "=>", update), console.info("previously", prev), console.trace(), console.groupEnd(), debug === "break")) debugger;
      return update;
    });
  }, [setter, debug]);
}
function mergeIfNotShallowEqual(prev, next) {
  return !prev || !next || isEqualShallow(prev, next) ? prev || next : {
    ...prev,
    ...next
  };
}
function isEqualShallow(prev, next) {
  for (const key in next) if (prev[key] !== next[key]) return false;
  return true;
}

// ../../node_modules/@tamagui/web/dist/esm/createComponent.mjs
var import_react17 = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/web/dist/esm/constants/isDevTools.mjs
var isDevTools = (() => {
  if (true) try {
    return new Function("try {return this===window;}catch(e){ return false;}")();
  } catch {
  }
  return false;
})();

// ../../node_modules/@tamagui/web/dist/esm/defaultComponentState.mjs
var defaultComponentState = {
  hover: false,
  press: false,
  pressIn: false,
  focus: false,
  focusVisible: false,
  focusWithin: false,
  unmounted: true,
  disabled: false
};
var defaultComponentStateMounted = {
  ...defaultComponentState,
  unmounted: false
};
var defaultComponentStateShouldEnter = {
  ...defaultComponentState,
  unmounted: "should-enter"
};

// ../../node_modules/@tamagui/web/dist/esm/helpers/getSplitStyles.mjs
var import_react14 = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/web/dist/esm/constants/accessibilityDirectMap.mjs
var accessibilityDirectMap = {};
{
  const items = {
    Hidden: true,
    ActiveDescendant: true,
    Atomic: true,
    AutoComplete: true,
    Busy: true,
    Checked: true,
    ColumnCount: "colcount",
    ColumnIndex: "colindex",
    ColumnSpan: "colspan",
    Current: true,
    Details: true,
    ErrorMessage: true,
    Expanded: true,
    HasPopup: true,
    Invalid: true,
    Label: true,
    Level: true,
    Modal: true,
    Multiline: true,
    MultiSelectable: true,
    Orientation: true,
    Owns: true,
    Placeholder: true,
    PosInSet: true,
    Pressed: true,
    RoleDescription: true,
    RowCount: true,
    RowIndex: true,
    RowSpan: true,
    Selected: true,
    SetSize: true,
    Sort: true,
    ValueMax: true,
    ValueMin: true,
    ValueNow: true,
    ValueText: true
  };
  for (const key in items) {
    let val = items[key];
    val === true && (val = key.toLowerCase()), accessibilityDirectMap[`accessibility${key}`] = `aria-${val}`;
  }
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/getGroupPropParts.mjs
function getGroupPropParts(groupProp) {
  const mediaQueries = getMedia(), [_, name, part3, part4] = groupProp.split("-");
  let pseudo;
  const media = part3 in mediaQueries ? part3 : void 0;
  return media ? pseudo = part4 : pseudo = part3, {
    name,
    pseudo,
    media
  };
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/createMediaStyle.mjs
var MEDIA_SEP = "_";
var prefixes = null;
var selectors = null;
var groupPseudoToPseudoCSSMap = {
  press: "active",
  focusVisible: "focus-visible",
  focusWithin: "focus-within"
};
var specificities = new Array(5).fill(0).map((_, i) => new Array(i).fill(":root").join(""));
function getThemeOrGroupSelector(name, styleInner, isGroup, groupParts, isTheme = false, precedenceImportancePrefix = "") {
  const selectorStart = styleInner.lastIndexOf(":root") + 5, selectorEnd = styleInner.lastIndexOf("{"), selector = styleInner.slice(selectorStart, selectorEnd), precedenceSpace = getSetting("themeClassNameOnRoot") && isTheme ? "" : " ", pseudoSelectorName = groupParts.pseudo ? groupPseudoToPseudoCSSMap[groupParts.pseudo] || groupParts.pseudo : void 0, pseudoSelector = pseudoSelectorName ? `:${pseudoSelectorName}` : "", presedencePrefix = `:root${precedenceImportancePrefix}${precedenceSpace}`, mediaSelector = `.t_${isGroup ? "group_" : ""}${name}${pseudoSelector}`;
  return [selector, `${presedencePrefix}${mediaSelector} ${selector.replaceAll(":root", "")}`];
}
var createMediaStyle = (styleObject, mediaKeyIn, mediaQueries, type, negate, priority) => {
  const [propertyIn, , identifier, pseudoIn, rules] = styleObject;
  let property = propertyIn;
  const enableMediaPropOrder = getSetting("mediaPropOrder"), isTheme = type === "theme", isPlatform = type === "platform", isGroup = type === "group", isNonWindowMedia = isTheme || isPlatform || isGroup, negKey = negate ? "0" : "", ogPrefix = identifier.slice(0, identifier.indexOf("-") + 1), id = `${ogPrefix}${MEDIA_SEP}${mediaKeyIn.replace("-", "")}${negKey}${MEDIA_SEP}`;
  let styleRule = "", groupPriority = "", groupMediaKey, containerName, nextIdentifier = identifier.replace(ogPrefix, id), styleInner = rules.map((rule) => rule.replace(identifier, nextIdentifier)).join(";"), isHover = false;
  if (isNonWindowMedia) {
    let specificity = (priority || 0) + (isGroup || isPlatform ? 1 : 0);
    if (isTheme || isGroup) {
      const groupParts = getGroupPropParts(isTheme ? "theme-" + mediaKeyIn : mediaKeyIn), {
        name,
        media,
        pseudo
      } = groupParts;
      groupMediaKey = media, isGroup && (containerName = name), (pseudo === "press" || pseudoIn === "active") && (specificity += 2), pseudo === "hover" && (isHover = true);
      const [selector, nextSelector] = getThemeOrGroupSelector(name, styleInner, isGroup, groupParts, isTheme, specificities[specificity]);
      styleRule = styleInner.replace(selector, nextSelector);
    } else styleRule = `${specificities[specificity]}${styleInner}`;
  }
  if (!isNonWindowMedia || groupMediaKey) {
    if (!selectors) {
      const mediaKeys2 = Object.keys(mediaQueries);
      selectors = Object.fromEntries(mediaKeys2.map((key) => [key, mediaObjectToString(mediaQueries[key])])), enableMediaPropOrder || (prefixes = Object.fromEntries(mediaKeys2.map((k, index) => [k, new Array(index + 1).fill(":root").join("")])));
    }
    const mediaKey = groupMediaKey || mediaKeyIn, mediaSelector = selectors[mediaKey], mediaQuery = `${negate ? "not all and " : ""}${mediaSelector}`, precedenceImportancePrefix = groupMediaKey ? groupPriority : enableMediaPropOrder && priority ? (
      // this new array should be cached
      specificities[priority]
    ) : (
      // @ts-ignore
      prefixes[mediaKey]
    ), prefix = groupMediaKey ? `@container ${containerName}` : "@media";
    groupMediaKey && (styleInner = styleRule), styleInner.includes(prefix) ? styleRule = styleInner.replace("{", ` and ${mediaQuery} {`).replace("and screen and", "and") : styleRule = `${prefix} ${mediaQuery}{${precedenceImportancePrefix}${styleInner}}`, groupMediaKey && (styleRule = `@supports (contain: ${getSetting("webContainerType") || "inline-size"}) {${styleRule}}`);
  }
  return isHover && (styleRule = `@media (hover:hover){${styleRule}}`), [property, void 0, nextIdentifier, void 0, [styleRule]];
};

// ../../node_modules/@tamagui/web/dist/esm/helpers/normalizeShadow.mjs
function normalizeShadow({
  shadowColor,
  shadowOffset,
  shadowOpacity,
  shadowRadius
}) {
  const {
    height,
    width
  } = shadowOffset || defaultOffset;
  return {
    shadowOffset: {
      width: width || 0,
      height: height || 0
    },
    shadowRadius: shadowRadius || 0,
    shadowColor: normalizeColor2(shadowColor, 1),
    shadowOpacity: shadowOpacity ?? (shadowColor ? getRgba(shadowColor)?.a : 1)
  };
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/expandStyles.mjs
function fixStyles(style) {
  (style.shadowRadius != null || style.shadowColor || style.shadowOpacity != null || style.shadowOffset) && Object.assign(style, normalizeShadow(style));
  for (const key in borderDefaults) key in style && (style[borderDefaults[key]] ||= "solid");
}
var nativeStyle = isWeb ? null : "borderStyle";
var borderDefaults = {
  borderWidth: "borderStyle",
  borderBottomWidth: nativeStyle || "borderBottomStyle",
  borderTopWidth: nativeStyle || "borderTopStyle",
  borderLeftWidth: nativeStyle || "borderLeftStyle",
  borderRightWidth: nativeStyle || "borderRightStyle"
  // TODO: need to add borderBlock and borderInline here, but they are alot and might impact performance
};

// ../../node_modules/@tamagui/web/dist/esm/helpers/insertStyleRule.mjs
var scannedCache = /* @__PURE__ */ new WeakMap();
var totalSelectorsInserted = /* @__PURE__ */ new Map();
var allSelectors = {};
var allRules = {};
var getAllSelectors = () => allSelectors;
var getAllRules = () => Object.keys(allRules).sort().map((key) => allRules[key]);
var lastScannedSheets = null;
function scanAllSheets(collectThemes = false, tokens) {
  if (!isClient) return;
  let themes2;
  const sheets = document.styleSheets || [], prev = lastScannedSheets, current = new Set(sheets);
  for (const sheet2 of current) if (sheet2) {
    const out = updateSheetStyles(sheet2, false, collectThemes, tokens);
    out && (themes2 = out);
  }
  if (lastScannedSheets = current, prev) for (const sheet2 of prev) sheet2 && !current.has(sheet2) && updateSheetStyles(sheet2, true);
  return themes2;
}
function trackInsertedStyle(id) {
  const next = (totalSelectorsInserted.get(id) || 0) + 1;
  return totalSelectorsInserted.set(id, next), next;
}
var bailAfterEnv = process.env.TAMAGUI_BAIL_AFTER_SCANNING_X_CSS_RULES;
var bailAfter = bailAfterEnv ? +bailAfterEnv : 400;
function updateSheetStyles(sheet2, remove = false, collectThemes = false, tokens) {
  let rules;
  try {
    if (rules = sheet2.cssRules, !rules) return;
  } catch {
    return;
  }
  const firstSelector = getTamaguiSelector(rules[0], collectThemes)?.[0], lastSelector = getTamaguiSelector(rules[rules.length - 1], collectThemes)?.[0], cacheKey = `${rules.length}${firstSelector}${lastSelector}`, lastScanned = scannedCache.get(sheet2);
  if (!remove && lastScanned === cacheKey) return;
  const len = rules.length;
  let fails = 0, dedupedThemes;
  const nameToTheme = {};
  for (let i = 0; i < len; i++) {
    const rule = rules[i];
    if (!(rule instanceof CSSStyleRule)) continue;
    const response = getTamaguiSelector(rule, collectThemes);
    if (response) fails = 0;
    else {
      if (fails++, fails > bailAfter) return;
      continue;
    }
    const [identifier, cssRule, isTheme] = response;
    if (isTheme) {
      const deduped = addThemesFromCSS(cssRule, tokens);
      if (deduped) {
        for (const name of deduped.names) nameToTheme[name] ? (Object.apply(nameToTheme[name], deduped.theme), deduped.names = deduped.names.filter((x) => x !== name)) : nameToTheme[name] = deduped.theme;
        dedupedThemes ||= [], dedupedThemes.push(deduped);
      }
      continue;
    }
  }
  return scannedCache.set(sheet2, cacheKey), dedupedThemes;
}
var colorVarToVal;
var rootComputedStyle = null;
function addThemesFromCSS(cssStyleRule, tokens) {
  const selectors2 = cssStyleRule.selectorText.split(",");
  if (!selectors2.length) return;
  if (tokens?.color && !colorVarToVal) {
    colorVarToVal = {};
    for (const key in tokens.color) {
      const token = tokens.color[key];
      colorVarToVal[token.name] = token.val;
    }
  }
  const rules = (cssStyleRule.cssText || "").slice(cssStyleRule.selectorText.length + 2, -1).split(";"), values = {};
  for (const rule of rules) {
    const sepI = rule.indexOf(":");
    if (sepI === -1) continue;
    const varIndex = rule.indexOf("--");
    let key = rule.slice(varIndex === -1 ? 0 : varIndex + 2, sepI);
    process.env.TAMAGUI_CSS_VARIABLE_PREFIX && (key = key.replace(process.env.TAMAGUI_CSS_VARIABLE_PREFIX, ""));
    const val = rule.slice(sepI + 2);
    let value;
    if (val[0] === "v" && val.startsWith("var(")) {
      const varName = val.slice(6, -1), tokenVal = colorVarToVal[varName];
      tokenVal ? value = tokenVal : (rootComputedStyle ||= getComputedStyle(document.body), value = rootComputedStyle.getPropertyValue("--" + varName));
    } else value = val;
    values[key] = createVariable({
      key,
      name: key,
      val: value
    }, true);
  }
  const names = /* @__PURE__ */ new Set();
  for (const selector of selectors2) {
    if (selector === " .tm_xxt") continue;
    const lastThemeSelectorIndex = selector.lastIndexOf(".t_"), name = selector.slice(lastThemeSelectorIndex).slice(3), [schemeChar] = selector[lastThemeSelectorIndex - 5], scheme = schemeChar === "d" ? "dark" : schemeChar === "i" ? "light" : "", themeName = scheme && scheme !== name ? `${scheme}_${name}` : name;
    !themeName || themeName === "light_dark" || themeName === "dark_light" || names.add(themeName);
  }
  return {
    names: [...names],
    theme: values
  };
}
var tamaguiSelectorRegex = /\.tm_xxt/;
function getTamaguiSelector(rule, collectThemes = false) {
  if (rule instanceof CSSStyleRule) {
    const text = rule.selectorText;
    if (text[0] === ":" && text[1] === "r" && tamaguiSelectorRegex.test(text)) {
      const id = getIdentifierFromTamaguiSelector(
        // next.js minifies it so its in front
        text.replace(tamaguiSelectorRegex, "")
      );
      return collectThemes ? [id, rule, true] : [id, rule];
    }
  } else if (rule instanceof CSSMediaRule) return rule.cssRules.length > 1 ? void 0 : getTamaguiSelector(rule.cssRules[0]);
}
var getIdentifierFromTamaguiSelector = (selector) => {
  const dotIndex = selector.indexOf(":");
  return dotIndex > -1 ? selector.slice(7, dotIndex) : selector.slice(7);
};
var sheet = null;
var trackAllRules = true;
function stopAccumulatingRules() {
  trackAllRules = false;
}
function updateRules(identifier, rules) {
  return trackAllRules && (allRules[identifier] = rules.join(" ")), true;
}
var nonce = "";
function insertStyleRules(rulesToInsert) {
  if (isClient) {
    if (!sheet && document.head) {
      const styleTag = document.createElement("style");
      styleTag.id = "_tamagui-styles", nonce && (styleTag.nonce = nonce), sheet = document.head.appendChild(styleTag).sheet;
    }
    if (sheet) for (const key in rulesToInsert) {
      const styleObject = rulesToInsert[key], identifier = styleObject[StyleObjectIdentifier];
      if (!shouldInsertStyleRules(identifier)) continue;
      const rules = styleObject[StyleObjectRules];
      allSelectors[identifier] = rules.join(`
`), trackInsertedStyle(identifier), updateRules(identifier, rules);
      try {
        for (const rule of rules) sheet.insertRule(rule, sheet.cssRules.length), identifier === "_dsp-_groupframe-maxMd_none" && console.warn("INSERT", rule);
      } catch {
      }
    }
  }
}
var maxToInsert = process.env.TAMAGUI_INSERT_SELECTOR_TRIES ? +process.env.TAMAGUI_INSERT_SELECTOR_TRIES : 1;
function shouldInsertStyleRules(identifier) {
  if (process.env.IS_STATIC === "is_static") return true;
  const total = totalSelectorsInserted.get(identifier) || 0;
  return total > +(process.env.TAMAGUI_STYLE_INSERTION_WARNING_LIMIT || 10) && console.warn('Warning: inserting many CSS rules, you may be animating something and generating many CSS insertions, which can degrade performance. Instead, try using the "disableClassName" property on elements that change styles often. To disable this warning set TAMAGUI_STYLE_INSERTION_WARNING_LIMIT from 50000 to something higher'), total < maxToInsert;
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/isActivePlatform.mjs
function isActivePlatform(key) {
  if (!key.startsWith("$platform")) return true;
  const platform = key.slice(10);
  return (
    // web, ios, android
    platform === currentPlatform || // web, native
    platform === "web"
  );
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/isActiveTheme.mjs
function isActiveTheme(key, activeThemeName) {
  if (key.startsWith("$theme-")) return key.slice(7).startsWith(activeThemeName);
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/log.mjs
function log(...args) {
  if (true) {
    _disableMediaTouch(true);
    try {
      return console.info(...args);
    } catch (err) {
      console.error(err);
    } finally {
      _disableMediaTouch(false);
    }
  }
}

// ../../node_modules/@tamagui/web/dist/esm/constants/webToNativeProps.mjs
var webToNativeDynamicExpansion = {};
var webToNativeExpansion = {};

// ../../node_modules/@tamagui/web/dist/esm/helpers/expandStyle.mjs
var neg1Flex = [["flexGrow", 0], ["flexShrink", 1], ["flexBasis", "auto"]];
function expandStyle(key, value) {
  if (key === "flex") return value === -1 ? neg1Flex : [["flexGrow", value], ["flexShrink", 1], ["flexBasis", getSetting("styleCompat") === "react-native" ? 0 : "auto"]];
  switch (key) {
    case "textAlignVertical":
      return [["verticalAlign", value === "center" ? "middle" : value]];
    case "writingDirection":
      return [["direction", value]];
    // some safari-based browsers seem not to support without -webkit prefix
    case "backdropFilter":
      return [["backdropFilter", value], ["WebkitBackdropFilter", value]];
  }
  if (key in EXPANSIONS) return EXPANSIONS[key].map((key2) => [key2, value]);
  if (key in webToNativeExpansion) return webToNativeExpansion[key].map((key2) => [key2, value]);
  if (key in webToNativeDynamicExpansion) return webToNativeDynamicExpansion[key](value);
}
var all = ["Top", "Right", "Bottom", "Left"];
var horiz = ["Right", "Left"];
var vert = ["Top", "Bottom"];
var xy = ["X", "Y"];
var EXPANSIONS = {
  borderColor: ["TopColor", "RightColor", "BottomColor", "LeftColor"],
  borderRadius: ["TopLeftRadius", "TopRightRadius", "BottomRightRadius", "BottomLeftRadius"],
  borderWidth: ["TopWidth", "RightWidth", "BottomWidth", "LeftWidth"],
  margin: all,
  marginHorizontal: horiz,
  marginVertical: vert,
  overscrollBehavior: xy,
  padding: all,
  paddingHorizontal: horiz,
  paddingVertical: vert,
  ...isWeb && {
    // react-native only supports borderStyle
    borderStyle: ["TopStyle", "RightStyle", "BottomStyle", "LeftStyle"],
    // react-native doesn't support X / Y
    overflow: xy
  }
};
for (const parent in EXPANSIONS) {
  const prefix = parent.slice(0, /[A-Z]/.exec(parent)?.index ?? parent.length);
  EXPANSIONS[parent] = EXPANSIONS[parent].map((k) => `${prefix}${k}`);
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/getVariantExtras.mjs
var cache5 = /* @__PURE__ */ new WeakMap();
var getVariantExtras = (styleState) => {
  if (cache5.has(styleState)) return cache5.get(styleState);
  const {
    props,
    conf: conf4,
    context,
    theme,
    styleProps
  } = styleState;
  let fonts = conf4.fontsParsed;
  context?.language && (fonts = getFontsForLanguage(conf4.fontsParsed, context.language));
  const next = {
    fonts,
    tokens: conf4.tokensParsed,
    theme,
    context: styleProps?.styledContext,
    get fontFamily() {
      return getVariableValue(styleState.fontFamily || styleState.props.fontFamily) || props.fontFamily || getVariableValue(getSetting("defaultFont"));
    },
    get font() {
      return fonts[this.fontFamily] || (!props.fontFamily || props.fontFamily[0] === "$" ? fonts[getSetting("defaultFont") || ""] : void 0);
    },
    props
  };
  return cache5.set(styleState, next), next;
};
var fontLanguageCache = /* @__PURE__ */ new WeakMap();
function getFontsForLanguage(fonts, language) {
  if (fontLanguageCache.has(language)) return fontLanguageCache.get(language);
  const next = {
    ...fonts,
    ...Object.fromEntries(Object.entries(language).map(([name, lang]) => {
      if (lang === "default") return [];
      const langKey = `$${name}_${lang}`;
      return [`$${name}`, fonts[langKey]];
    }))
  };
  return fontLanguageCache.set(language, next), next;
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/isObj.mjs
var isObj = (x) => x && !Array.isArray(x) && typeof x == "object";

// ../../node_modules/@tamagui/web/dist/esm/helpers/normalizeStyle.mjs
function normalizeStyle(style, disableNormalize = false) {
  const res = {};
  for (let key in style) {
    const prop = style[key];
    if (prop == null) continue;
    if (key in pseudoDescriptors || // this should capture all parent-based styles like media, group, etc
    key[0] === "$" && isObj(prop)) {
      res[key] = normalizeStyle(prop, disableNormalize);
      continue;
    }
    const value = disableNormalize ? prop : normalizeValueWithProperty(prop, key), out = expandStyle(key, value);
    out ? Object.assign(res, Object.fromEntries(out)) : res[key] = value;
  }
  return fixStyles(res), res;
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/skipProps.mjs
var skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1,
  themeInverse: 1,
  animatePresence: 1
};
Object.assign(skipProps, {
  accessibilityElementsHidden: 1,
  accessibilityIgnoresInvertColors: 1,
  accessibilityLanguage: 1,
  adjustsFontSizeToFit: 1,
  allowFontScaling: 1,
  android_hyphenationFrequency: 1,
  dataDetectorType: 1,
  dynamicTypeRamp: 1,
  elevationAndroid: 1,
  ellipsizeMode: 1,
  hapticFeedback: 1,
  hapticStyle: 1,
  hitSlop: 1,
  importantForAccessibility: 1,
  lineBreakStrategyIOS: 1,
  maxFontSizeMultiplier: 1,
  minimumFontScale: 1,
  needsOffscreenAlphaCompositing: 1,
  nextFocusDown: 1,
  nextFocusForward: 1,
  nextFocusLeft: 1,
  nextFocusRight: 1,
  nextFocusUp: 1,
  onAccessibilityAction: 1,
  onAccessibilityEscape: 1,
  onAccessibilityTap: 1,
  onMagicTap: 1,
  onTextLayout: 1,
  pressRetentionOffset: 1,
  selectionColor: 1,
  shouldRasterizeIOS: 1,
  suppressHighlighting: 1,
  textBreakStrategy: 1
});

// ../../node_modules/@tamagui/web/dist/esm/helpers/propMapper.mjs
var propMapper = (key, value, styleState, disabled, map) => {
  if (disabled) return map(key, value);
  if (lastFontFamilyToken = null, key === "elevationAndroid") return;
  const {
    conf: conf4,
    styleProps,
    staticConfig
  } = styleState;
  if (value === "unset") {
    const unsetVal = conf4.unset?.[key];
    if (unsetVal != null) value = unsetVal;
    else return;
  }
  const {
    variants
  } = staticConfig;
  if (!styleProps.noExpand && variants && key in variants) {
    const variantValue = resolveVariants(key, value, styleProps, styleState, "");
    if (variantValue) {
      variantValue.forEach(([key2, value2]) => map(key2, value2));
      return;
    }
  }
  styleProps.disableExpandShorthands || key in conf4.shorthands && (key = conf4.shorthands[key]);
  const originalValue = value;
  if (value != null && (value[0] === "$" ? value = getTokenForKey(key, value, styleProps, styleState) : isVariable(value) && (value = resolveVariableValue(key, value, styleProps.resolveValues))), value != null) {
    key === "fontFamily" && lastFontFamilyToken && (styleState.fontFamily = lastFontFamilyToken);
    const expanded = styleProps.noExpand ? null : expandStyle(key, value);
    if (expanded) {
      const max = expanded.length;
      for (let i = 0; i < max; i++) {
        const [nkey, nvalue] = expanded[i];
        map(nkey, nvalue, originalValue);
      }
    } else map(key, value, originalValue);
  }
};
var resolveVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  const {
    staticConfig,
    conf: conf4,
    debug
  } = styleState, {
    variants
  } = staticConfig;
  if (!variants) return;
  let variantValue = getVariantDefinition(variants[key], value, conf4);
  if (debug === "verbose" && (console.groupCollapsed(`â™¦ï¸â™¦ï¸â™¦ï¸ resolve variant ${key}`), console.info({
    key,
    value,
    variantValue,
    variants
  }), console.groupEnd()), !variantValue) {
    if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1" && typeof value != "boolean") {
      const name = staticConfig.componentName || "[UnnamedComponent]";
      console.warn(`No variant found: ${name} has variant "${key}", but no matching value "${value}"`);
    }
    return;
  }
  if (typeof variantValue == "function") {
    const fn = variantValue, extras = getVariantExtras(styleState);
    variantValue = fn(value, extras), debug === "verbose" && (console.groupCollapsed("   expanded functional variant", key), console.info({
      fn,
      variantValue,
      extras
    }), console.groupEnd());
  }
  let fontFamilyResult;
  if (isObj(variantValue)) {
    const fontFamilyUpdate = variantValue.fontFamily || variantValue[conf4.inverseShorthands.fontFamily];
    fontFamilyUpdate && (fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf4), styleState.fontFamily = fontFamilyResult, debug === "verbose" && console.info("   updating font family", fontFamilyResult)), variantValue = resolveTokensAndVariants(key, variantValue, styleProps, styleState, parentVariantKey);
  }
  if (variantValue) {
    const expanded = normalizeStyle(variantValue, !!styleProps.noNormalize);
    debug === "verbose" && console.info("   expanding styles from ", variantValue, "to", expanded);
    const next = Object.entries(expanded);
    return fontFamilyResult && fontFamilyResult[0] === "$" && (lastFontFamilyToken = getVariableValue(fontFamilyResult)), next;
  }
};
function getFontFamilyFromNameOrVariable(input, conf4) {
  if (isVariable(input)) {
    const val = variableToFontNameCache.get(input);
    if (val) return val;
    for (const key in conf4.fontsParsed) {
      const familyVariable = conf4.fontsParsed[key].family;
      if (isVariable(familyVariable) && (variableToFontNameCache.set(familyVariable, key), familyVariable === input)) return key;
    }
  } else if (typeof input == "string" && input[0] === "$") return input;
}
var variableToFontNameCache = /* @__PURE__ */ new WeakMap();
var resolveTokensAndVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  const {
    conf: conf4,
    staticConfig,
    debug,
    theme
  } = styleState, {
    variants
  } = staticConfig, res = {};
  debug === "verbose" && console.info("   - resolveTokensAndVariants", key, value);
  for (const _key in value) {
    const subKey = conf4.shorthands[_key] || _key, val = value[_key];
    if (!(!styleProps.noSkip && subKey in skipProps)) {
      if (staticConfig) {
        const contextProps = staticConfig.context?.props || staticConfig.parentStaticConfig?.context?.props;
        contextProps && subKey in contextProps && (styleState.overriddenContextProps ||= {}, styleState.overriddenContextProps[subKey] = val, styleState.originalContextPropValues ||= {}, styleState.originalContextPropValues[subKey] = val);
      }
      if (styleProps.noExpand) res[subKey] = val;
      else if (variants && subKey in variants) {
        if (parentVariantKey && parentVariantKey === key) res[subKey] = // SYNC WITH *1
        val[0] === "$" ? getTokenForKey(subKey, val, styleProps, styleState) : val;
        else {
          const variantOut = resolveVariants(subKey, val, styleProps, styleState, key);
          if (variantOut) for (const [key2, val2] of variantOut) val2 != null && (key2 in pseudoDescriptors ? (res[key2] ??= {}, Object.assign(res[key2], val2)) : res[key2] = val2);
        }
        continue;
      }
      if (isVariable(val)) {
        res[subKey] = resolveVariableValue(subKey, val, styleProps.resolveValues), debug === "verbose" && console.info("variable", subKey, res[subKey]);
        continue;
      }
      if (typeof val == "string") {
        const fVal = (
          // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps, styleState) : val
        );
        res[subKey] = fVal;
        continue;
      }
      if (isObj(val)) {
        const subObject = resolveTokensAndVariants(subKey, val, styleProps, styleState, key);
        debug === "verbose" && console.info("object", subKey, subObject), res[subKey] ??= {}, Object.assign(res[subKey], subObject);
      } else res[subKey] = val;
      debug && res[subKey]?.[0] === "$" && console.warn(`âš ï¸ Missing token in theme ${theme.name}:`, subKey, res[subKey], theme);
    }
  }
  return res;
};
var tokenCats = ["size", "color", "radius", "space", "zIndex"].map((name) => ({
  name,
  spreadName: `...${name}`
}));
function getVariantDefinition(variant, value, conf4) {
  if (!variant) return;
  if (typeof variant == "function") return variant;
  const exact = variant[value];
  if (exact) return exact;
  if (value != null) {
    const {
      tokensParsed
    } = conf4;
    for (const {
      name,
      spreadName
    } of tokenCats) if (spreadName in variant && name in tokensParsed && value in tokensParsed[name]) return variant[spreadName];
    const fontSizeVariant = variant["...fontSize"];
    if (fontSizeVariant && conf4.fontSizeTokens.has(value)) return fontSizeVariant;
  }
  return variant[`:${typeof value}`] || variant["..."];
}
var fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
};
var lastFontFamilyToken = null;
var didLogMissingToken = false;
var getTokenForKey = (key, value, styleProps, styleState) => {
  let resolveAs = styleProps.resolveValues || "none";
  if (resolveAs === "none") return value;
  const {
    theme,
    conf: conf4 = getConfig(),
    context,
    fontFamily,
    staticConfig
  } = styleState, themeValue = theme ? theme[value] || theme[value.slice(1)] : void 0, tokensParsed = conf4.tokensParsed;
  let valOrVar, hasSet = false;
  const customTokenAccept = staticConfig?.accept?.[key];
  if (customTokenAccept) {
    const val = themeValue ?? tokensParsed[customTokenAccept][value];
    val != null && (resolveAs = "value", valOrVar = val, hasSet = true);
  }
  if (themeValue) {
    if (resolveAs === "except-theme") return value;
    valOrVar = themeValue, styleState.debug === "verbose" && (globalThis.tamaguiAvoidTracking = true, console.info(` - resolving ${key} to theme value ${value} resolveAs ${resolveAs}`, valOrVar), globalThis.tamaguiAvoidTracking = false), hasSet = true;
  } else {
    if (value in conf4.specificTokens) hasSet = true, valOrVar = conf4.specificTokens[value];
    else {
      switch (key) {
        case "fontFamily": {
          valOrVar = (context?.language ? getFontsForLanguage(conf4.fontsParsed, context.language) : conf4.fontsParsed)[value]?.family || value, lastFontFamilyToken = value, hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          const fam = fontFamily || conf4.defaultFontToken;
          if (fam) {
            const fontsParsed = context?.language ? getFontsForLanguage(conf4.fontsParsed, context.language) : conf4.fontsParsed;
            valOrVar = (fontsParsed[fam] || fontsParsed[conf4.defaultFontToken])?.[fontShorthand[key] || key]?.[value] || value, hasSet = true;
          }
          break;
        }
      }
      for (const cat in tokenCategories) if (key in tokenCategories[cat]) {
        const res = tokensParsed[cat]?.[value];
        res != null ? (valOrVar = res, hasSet = true) : process.env.TAMAGUI_DISABLE_MISSING_TOKEN_LOG !== "1" && (didLogMissingToken || (didLogMissingToken = true, console.groupCollapsed(`[tamagui] Warning: missing token ${key} in category ${cat} - ${value} (open for details)`), console.info(`Note: this could just be due to you not setting all the theme tokens Tamagui expects, which is harmless, but
                    it also often can be because you have a duplicated Tamagui in your bundle, which can cause tricky bugs.`), console.info(`To see if you have duplicated dependencies, in Chrome DevTools hit CMD+P and type TamaguiProvider.
                    If you see both a .cjs and a .mjs entry, it's duplicated.`), console.info("You can debug that issue by opening the .mjs and .cjs files and setting a breakpoint at the top of each."), console.info("We only log this warning one time as it's sometimes harmless, to disable this log entirely set process.env.TAMAGUI_DISABLE_MISSING_TOKEN_LOG=1."), console.groupEnd()));
      }
    }
    if (!hasSet) {
      const spaceVar = tokensParsed.space[value];
      spaceVar != null && (valOrVar = spaceVar, hasSet = true);
    }
  }
  if (hasSet) {
    const out = resolveVariableValue(key, valOrVar, resolveAs);
    return styleState.debug === "verbose" && (globalThis.tamaguiAvoidTracking = true, console.info("resolved", resolveAs, valOrVar, out), globalThis.tamaguiAvoidTracking = false), out;
  }
  styleState.debug === "verbose" && console.warn(`Warning: no token found for ${key}, omitting`);
};
function resolveVariableValue(key, valOrVar, resolveValues) {
  if (resolveValues === "none") return valOrVar;
  if (isVariable(valOrVar)) {
    if (resolveValues === "value") return valOrVar.val;
    const get = valOrVar?.get;
    return typeof get == "function" ? get(resolveValues === "web" ? "web" : void 0) : valOrVar.variable;
  }
  return valOrVar;
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/sortString.mjs
var sortString = (a, b) => a < b ? -1 : a > b ? 1 : 0;

// ../../node_modules/@tamagui/web/dist/esm/helpers/getSplitStyles.mjs
var conf3;
var styleOriginalValues = /* @__PURE__ */ new WeakMap();
var PROP_SPLIT = "-";
function normalizeGroupKey(key, groupContext) {
  const parts = key.split("-"), plen = parts.length;
  if (
    // check if its actually a simple group selector to avoid breaking selectors
    plen === 2 || plen === 3 && pseudoPriorities[parts[parts.length - 1]]
  ) {
    const name = parts[1];
    if (groupContext && !groupContext[name]) return key.replace("$group-", "$group-true-");
  }
  return key;
}
function isValidStyleKey(key, validStyles2, accept) {
  return key in validStyles2 ? true : accept && key in accept;
}
var getSplitStyles = (props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, componentContext, groupContext, elementType, startedUnhydrated, debug) => {
  conf3 = conf3 || getConfig();
  const animationDriver = componentContext?.animationDriver || conf3.animations;
  if (props.passThrough) return null;
  isWeb && styleProps.isAnimated && animationDriver.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  const {
    shorthands
  } = conf3, {
    isHOC,
    isText,
    isInput,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState2 = styleProps.mediaState || mediaState, shouldDoClasses = acceptsClassName && isWeb && !styleProps.noClass, rulesToInsert = {}, classNames = {};
  let space = props.space, pseudos = null, hasMedia = false, dynamicThemeAccess, pseudoGroups, mediaGroups, className = props.className || "", mediaStylesSeen = 0;
  const validStyles2 = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  debug === "profile" && time`split-styles-setup`;
  const styleState = {
    classNames,
    conf: conf3,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys: {},
    viewProps,
    context: componentContext,
    debug
  };
  if (process.env.IS_STATIC === "is_static") {
    const {
      fallbackProps
    } = styleProps;
    fallbackProps && (styleState.props = new Proxy(props, {
      get(_, key, val) {
        return Reflect.has(props, key) ? Reflect.get(props, key) : Reflect.get(fallbackProps, key);
      }
    }));
  }
  debug === "profile" && time`style-state`, debug === "verbose" && isClient && isDevTools && (console.groupCollapsed("ðŸ”¹ getSplitStyles ðŸ‘‡"), log({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    rulesToInsert,
    componentState,
    styleState,
    theme: {
      ...theme
    }
  }));
  const {
    asChild
  } = props, {
    accept
  } = staticConfig, {
    noSkip,
    disableExpandShorthands,
    noExpand,
    styledContext
  } = styleProps, {
    webContainerType
  } = conf3.settings, parentVariants = parentStaticConfig?.variants;
  for (const keyOg in props) {
    let keyInit = keyOg, valInit = props[keyInit];
    if (keyInit === "children") {
      viewProps[keyInit] = valInit;
      continue;
    }
    if (debug === "profile" && time`before-prop-${keyInit}`, false) continue;
    if (accept) {
      const accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && typeof valInit == "object") {
        viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps.noClass);
        continue;
      }
    }
    if ("development", disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className" || asChild && webViewFlexCompatStyles[keyInit] === valInit) continue;
    if (keyInit in skipProps && !noSkip && !isHOC) {
      if (keyInit === "group") {
        const identifier = `t_group_${valInit}`, containerCSS = ["continer", void 0, identifier, void 0, [`.${identifier} { container-name: ${valInit}; container-type: ${webContainerType || "inline-size"}; }`]];
        addStyleToInsertRules(rulesToInsert, containerCSS);
      }
      continue;
    }
    let isValidStyleKeyInit = isValidStyleKey(keyInit, validStyles2, accept);
    if (staticConfig.isReactNative && keyInit.startsWith("data-")) {
      keyInit = keyInit.replace("data-", ""), viewProps.dataSet ||= {}, viewProps.dataSet[keyInit] = valInit;
      continue;
    }
    if (keyInit === "dataSet") {
      for (const keyInit2 in valInit) viewProps[`data-${hyphenate(keyInit2)}`] = valInit[keyInit2];
      continue;
    }
    if (!noExpand) {
      if (keyInit === "disabled" && valInit === true && (viewProps["aria-disabled"] = true, (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.disabled = true), !variants?.disabled)) continue;
      if (keyInit === "testID") {
        viewProps[isReactNative ? keyInit : "data-testid"] = valInit;
        continue;
      }
      if (keyInit === "id" || keyInit === "nativeID") {
        viewProps.id = valInit;
        continue;
      }
      let didUseKeyInit = false;
      if (isReactNative) {
        if (keyInit in accessibilityDirectMap || keyInit.startsWith("accessibility")) {
          viewProps[keyInit] = valInit;
          continue;
        }
      } else {
        if (didUseKeyInit = true, keyInit in accessibilityDirectMap) {
          viewProps[accessibilityDirectMap[keyInit]] = valInit;
          continue;
        }
        switch (keyInit) {
          case "accessibilityRole": {
            valInit === "none" ? viewProps.role = "presentation" : viewProps.role = accessibilityRoleToWebRole[valInit] || valInit;
            continue;
          }
          case "accessibilityLabelledBy":
          case "accessibilityFlowTo":
          case "accessibilityControls":
          case "accessibilityDescribedBy": {
            viewProps[`aria-${keyInit.replace("accessibility", "").toLowerCase()}`] = processIDRefList(valInit);
            continue;
          }
          case "accessibilityKeyShortcuts": {
            Array.isArray(valInit) && (viewProps["aria-keyshortcuts"] = valInit.join(" "));
            continue;
          }
          case "accessibilityLiveRegion": {
            viewProps["aria-live"] = valInit === "none" ? "off" : valInit;
            continue;
          }
          case "accessibilityReadOnly": {
            viewProps["aria-readonly"] = valInit, (elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.readOnly = true);
            continue;
          }
          case "accessibilityRequired": {
            viewProps["aria-required"] = valInit, (elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.required = valInit);
            continue;
          }
          default:
            didUseKeyInit = false;
        }
      }
      if (didUseKeyInit) continue;
    }
    let isVariant = !isValidStyleKeyInit && variants && keyInit in variants;
    const isStyleLikeKey = isValidStyleKeyInit || isVariant;
    let isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo ? getMediaKey(keyInit) : false, isMediaOrPseudo = !!(isMedia || isPseudo);
    isMediaOrPseudo && isMedia === "group" && (keyInit = normalizeGroupKey(keyInit, groupContext));
    const isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web")) continue;
    const shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || inlineProps?.has(keyInit), parentVariant = parentVariants?.[keyInit], isHOCShouldPassThrough = !!(isHOC && (isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (debug === "verbose" && (console.groupCollapsed(`  ðŸ”‘ ${keyOg}${keyInit !== keyOg ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""}`), log({
      isVariant,
      valInit,
      shouldPassProp
    }), isClient && log({
      variants,
      variant: variants?.[keyInit],
      isVariant,
      isHOCShouldPassThrough,
      usedKeys: {
        ...styleState.usedKeys
      },
      parentStaticConfig
    })), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), debug === "verbose" && console.groupEnd(), !isVariant)) continue;
    if (!noSkip && keyInit in skipProps) {
      debug === "verbose" && console.groupEnd();
      continue;
    }
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf3.fontsParsed && (styleState.fontFamily = valInit);
    const disablePropMap = isMediaOrPseudo || !isStyleLikeKey;
    if (propMapper(keyInit, valInit, styleState, disablePropMap, (key, val, originalVal) => {
      const isStyledContextProp = styledContext && key in styledContext;
      if (!isHOC && disablePropMap && !isStyledContextProp && !isMediaOrPseudo) {
        viewProps[key] = val;
        return;
      }
      if (debug === "verbose" && (console.groupCollapsed("  ðŸ’  expanded", keyInit, "=>", key), log(val), console.groupEnd()), val == null) return;
      if (!isHOC && isValidStyleKey(key, validStyles2, accept)) {
        mergeStyle(styleState, key, val, 1, false, originalVal);
        return;
      }
      if (isPseudo = key in validPseudoKeys, isMedia = isPseudo ? false : getMediaKey(key), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key in variants, isMedia === "group" && (key = normalizeGroupKey(key, groupContext)), (inlineProps?.has(key) || process.env.IS_STATIC === "is_static" && inlineWhenUnflattened?.has(key)) && (viewProps[key] = props[key] ?? val), styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo || parentStaticConfig?.variants?.[keyInit])) {
        passDownProp(viewProps, key, val, isMediaOrPseudo), debug === "verbose" && (console.groupCollapsed(` - passing down prop ${key}`), log({
          val,
          after: {
            ...viewProps[key]
          }
        }), console.groupEnd());
        return;
      }
      if (isPseudo) {
        if (!val) return;
        const pseudoStyleObject = getSubStyle(styleState, key, val, styleProps.noClass && process.env.IS_STATIC !== "is_static");
        if ((!shouldDoClasses || process.env.IS_STATIC === "is_static") && (pseudos ||= {}, pseudos[key] ||= {}, process.env.IS_STATIC === "is_static")) {
          Object.assign(pseudos[key], pseudoStyleObject);
          return;
        }
        const descriptor = pseudoDescriptors[key], isEnter = key === "enterStyle", isExit = key === "exitStyle";
        if (!descriptor) return;
        if (shouldDoClasses && !isExit) {
          const pseudoStyles = getStyleAtomic(pseudoStyleObject, descriptor);
          debug === "verbose" && console.info("pseudo:", key, pseudoStyleObject, pseudoStyles);
          for (const psuedoStyle of pseudoStyles) {
            const fullKey = `${psuedoStyle[StyleObjectProperty]}${PROP_SPLIT}${descriptor.name}`;
            addStyleToInsertRules(rulesToInsert, psuedoStyle), classNames[fullKey] = psuedoStyle[StyleObjectIdentifier];
          }
        }
        if (!shouldDoClasses || isExit || isEnter) {
          const descriptorKey = descriptor.stateKey || descriptor.name;
          let isDisabled2 = componentState[descriptorKey] === false;
          isExit && (isDisabled2 = !styleProps.isExiting), isEnter && componentState.unmounted === false && (isDisabled2 = true), debug === "verbose" && (console.groupCollapsed("pseudo", key, {
            isDisabled: isDisabled2
          }), log({
            pseudoStyleObject,
            isDisabled: isDisabled2,
            descriptor,
            componentState
          }), console.groupEnd());
          const importance = descriptor.priority, pseudoOriginalValues = styleOriginalValues.get(pseudoStyleObject);
          for (const pkey in pseudoStyleObject) {
            const val2 = pseudoStyleObject[pkey];
            if (isDisabled2) applyDefaultStyle(pkey, styleState);
            else {
              const curImportance = styleState.usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
              shouldMerge && (process.env.IS_STATIC === "is_static" && (pseudos ||= {}, pseudos[key] ||= {}, pseudos[key][pkey] = val2), mergeStyle(styleState, pkey, val2, importance, false, pseudoOriginalValues?.[pkey])), debug === "verbose" && log("    subKey", pkey, shouldMerge, {
                importance,
                curImportance,
                pkey,
                val: val2
              });
            }
          }
          if (!isDisabled2) for (const key2 in val) {
            const k = shorthands[key2] || key2;
            styleState.usedKeys[k] = Math.max(importance, styleState.usedKeys[k] || 0);
          }
        }
        return;
      }
      if (isMedia) {
        if (!val) return;
        const hasSpace = val.space, mediaKeyShort = key.slice(isMedia == "theme" ? 7 : 1);
        if (hasMedia ||= true, (hasSpace || !shouldDoClasses || styleProps.willBeAnimated) && ((!hasMedia || typeof hasMedia == "boolean") && (hasMedia = /* @__PURE__ */ new Set()), hasMedia.add(mediaKeyShort)), isMedia === "platform" && !isActivePlatform(key)) return;
        debug === "verbose" && log(`  ðŸ“º ${key}`, {
          key,
          val,
          props,
          shouldDoClasses,
          acceptsClassName,
          componentState,
          mediaState: mediaState2
        });
        const priority = mediaStylesSeen;
        if (mediaStylesSeen += 1, shouldDoClasses) {
          const mediaStyle = getSubStyle(styleState, key, val, false);
          if (hasSpace && (delete mediaStyle.space, mediaState2[mediaKeyShort])) {
            const importance = getMediaImportanceIfMoreImportant(mediaKeyShort, "space", styleState, true);
            importance && (space = val.space, styleState.usedKeys.space = importance, debug === "verbose" && log(`Found more important space for current media ${mediaKeyShort}: ${val} (importance: ${importance})`));
          }
          const mediaStyles = getCSSStylesAtomic(mediaStyle);
          for (const style of mediaStyles) {
            const property = style[StyleObjectProperty], isSubStyle = property[0] === "$";
            if (isSubStyle && !isActivePlatform(property)) continue;
            const out = createMediaStyle(style, mediaKeyShort, mediaQueryConfig, isMedia, false, priority);
            debug === "verbose" && log("ðŸ“º media style:", out);
            const subKey = isSubStyle ? style[2] : "", fullKey = `${style[StyleObjectProperty]}${subKey}${PROP_SPLIT}${mediaKeyShort}${style[StyleObjectPseudo] || ""}`;
            addStyleToInsertRules(rulesToInsert, out), classNames[fullKey] = out[StyleObjectIdentifier];
          }
        } else {
          let mergeMediaStyle = function(key2, val2, originalVal2) {
            styleState.style ||= {}, mergeMediaByImportance(styleState, mediaKeyShort, key2, val2, mediaState2[mediaKeyShort], importanceBump, debug, originalVal2) && key2 === "fontFamily" && (styleState.fontFamily = mediaStyle.fontFamily);
          };
          const isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group";
          if (!isThemeMedia && !(isMedia === "platform") && !isGroupMedia) {
            if (!mediaState2[mediaKeyShort]) {
              debug === "verbose" && log(`  ðŸ“º âŒ DISABLED ${mediaKeyShort}`);
              return;
            }
            debug === "verbose" && log(`  ðŸ“º âœ… ENABLED ${mediaKeyShort}`);
          }
          const mediaStyle = getSubStyle(styleState, key, val, true);
          let importanceBump = 0;
          if (isThemeMedia) {
            if (dynamicThemeAccess = true, !(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort))) return;
          } else if (isGroupMedia) {
            const groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupState = groupContext?.[groupName]?.state, groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media;
            if (!groupState) {
              debug && log(`No parent with group prop, skipping styles: ${groupName}`), pseudoGroups ||= /* @__PURE__ */ new Set();
              return;
            }
            const componentGroupState = componentState.group?.[groupName];
            if (groupMediaKey) {
              mediaGroups ||= /* @__PURE__ */ new Set(), mediaGroups.add(groupMediaKey);
              const mediaState22 = componentGroupState?.media;
              let isActive = mediaState22?.[groupMediaKey];
              if (!mediaState22 && groupState.layout && (isActive = mediaKeyMatch(groupMediaKey, groupState.layout)), debug === "verbose" && log(` ðŸ˜ï¸ GROUP media ${groupMediaKey} active? ${isActive}`, {
                ...mediaState22,
                usedKeys: {
                  ...styleState.usedKeys
                }
              }), !isActive) {
                for (const pkey in mediaStyle) applyDefaultStyle(pkey, styleState);
                return;
              }
              importanceBump = 2;
            }
            if (groupPseudoKey) {
              pseudoGroups ||= /* @__PURE__ */ new Set(), pseudoGroups.add(groupName);
              const componentGroupPseudoState = (componentGroupState || // fallback to context initially
              groupContext?.[groupName].state)?.pseudo, isActive = componentGroupPseudoState?.[groupPseudoKey], priority2 = pseudoPriorities[groupPseudoKey];
              if (debug === "verbose" && log(` ðŸ˜ï¸ GROUP pseudo ${groupMediaKey} active? ${isActive}, priority ${priority2}`, {
                componentGroupPseudoState: {
                  ...componentGroupPseudoState
                },
                usedKeys: {
                  ...styleState.usedKeys
                }
              }), !isActive) {
                for (const pkey in mediaStyle) applyDefaultStyle(pkey, styleState);
                return;
              }
              importanceBump = priority2;
            }
          }
          const mediaOriginalValues = styleOriginalValues.get(mediaStyle);
          for (const subKey in mediaStyle) {
            if (subKey === "space") {
              space = valInit.space;
              continue;
            }
            if (subKey[0] === "$") {
              if (!isActivePlatform(subKey) || !isActiveTheme(subKey, themeName)) continue;
              const subOriginalValues = styleOriginalValues.get(mediaStyle[subKey]);
              for (const subSubKey in mediaStyle[subKey]) mergeMediaStyle(subSubKey, mediaStyle[subKey][subSubKey], subOriginalValues?.[subSubKey]);
            } else mergeMediaStyle(subKey, mediaStyle[subKey], mediaOriginalValues?.[subKey]);
          }
        }
        return;
      }
      if (!isVariant) {
        if (isStyledContextProp) return;
        viewProps[key] = val;
      }
    }), debug === "verbose") {
      try {
        log(" âœ”ï¸ expand complete", keyInit), log("style", {
          ...styleState.style
        }), log("viewProps", {
          ...viewProps
        }), log("transforms", {
          ...styleState.flatTransforms
        });
      } catch {
      }
      console.groupEnd();
    }
  }
  if (debug === "profile" && time`split-styles-propsend`, !(styleProps.noNormalize === false) && (styleState.style && (fixStyles(styleState.style), !styleProps.noExpand && !styleProps.noMergeStyle && isWeb && (!isReactNative || !animationDriver.supportsCSS) && styleToCSS(styleState.style)), styleState.flatTransforms && (styleState.style ||= {}, mergeFlatTransforms(styleState.style, styleState.flatTransforms)), parentSplitStyles)) {
    if (shouldDoClasses) for (const key in parentSplitStyles.classNames) {
      const val = parentSplitStyles.classNames[key];
      styleState.style && key in styleState.style || key in classNames || (classNames[key] = val);
    }
    if (!shouldDoClasses) for (const key in parentSplitStyles.style) key in classNames || styleState.style && key in styleState.style || (styleState.style ||= {}, styleState.style[key] = parentSplitStyles.style[key]);
  }
  if (!styleProps.noNormalize && !staticConfig.isReactNative && !staticConfig.isHOC && (!styleProps.isAnimated || animationDriver.supportsCSS) && Array.isArray(styleState.style?.transform) && (styleState.style.transform = transformsToString(styleState.style.transform)), !styleProps.noMergeStyle && styleState.style && shouldDoClasses) {
    let retainedStyles, shouldRetain = false;
    if (!styleState.style.$$css) {
      const atomic = getCSSStylesAtomic(styleState.style);
      for (const atomicStyle of atomic) {
        const [key, value, identifier] = atomicStyle, isAnimatedAndAnimateOnly = styleProps.isAnimated && styleProps.noClass && props.animateOnly?.includes(key), nonAnimatedAnimateOnly = !isAnimatedAndAnimateOnly && !styleProps.isAnimated && props.animateOnly?.includes(key);
        isAnimatedAndAnimateOnly ? (retainedStyles ||= {}, retainedStyles[key] = styleState.style[key]) : nonAnimatedAnimateOnly ? (retainedStyles ||= {}, retainedStyles[key] = value, shouldRetain = true) : (addStyleToInsertRules(rulesToInsert, atomicStyle), classNames[key] = identifier);
      }
      props.debug === "verbose" && (console.groupCollapsed("ðŸ”¹ getSplitStyles final style object"), console.info(styleState.style), console.info("retainedStyles", retainedStyles), console.groupEnd()), (shouldRetain || process.env.IS_STATIC !== "is_static") && (styleState.style = retainedStyles || {});
    }
  }
  if (isReactNative) viewProps.tabIndex === 0 && (viewProps.accessible ??= true);
  else if (viewProps.tabIndex == null) {
    const isFocusable = viewProps.focusable ?? viewProps.accessible;
    viewProps.focusable && delete viewProps.focusable;
    const role = viewProps.role;
    isFocusable === false && (viewProps.tabIndex = "-1"), // These native elements are focusable by default
    elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea" ? (isFocusable === false || props.accessibilityDisabled === true) && (viewProps.tabIndex = "-1") : (
      // These roles are made focusable by default
      (role === "button" || role === "checkbox" || role === "link" || role === "radio" || // @ts-expect-error (consistent with RNW)
      role === "textbox" || role === "switch") && isFocusable !== false && (viewProps.tabIndex = "0")
    ), isFocusable && (viewProps.tabIndex = "0", delete viewProps.focusable);
  }
  const styleProp = props.style;
  if (!styleProps.noMergeStyle && styleProp) if (isHOC) viewProps.style = normalizeStyle2(styleProp);
  else {
    const isArray = Array.isArray(styleProp), len = isArray ? styleProp.length : 1;
    for (let i = 0; i < len; i++) {
      const style = isArray ? styleProp[i] : styleProp;
      style && (style.$$css ? Object.assign(styleState.classNames, style) : (styleState.style ||= {}, Object.assign(styleState.style, normalizeStyle2(style))));
    }
  }
  debug === "profile" && time`split-styles-pre-result`;
  const result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups,
    overriddenContextProps: styleState.overriddenContextProps
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!styleProps.noMergeStyle && !asChildExceptStyleLike) {
    const style = styleState.style;
    {
      let fontFamily = isText || isInput ? styleState.fontFamily || staticConfig.defaultProps?.fontFamily : null;
      fontFamily && fontFamily[0] === "$" && (fontFamily = fontFamily.slice(1));
      const fontFamilyClassName = fontFamily ? `font_${fontFamily}` : "", groupClassName = props.group ? `t_group_${props.group}` : "", componentNameFinal = props.componentName || staticConfig.componentName, componentClassName = props.asChild || !componentNameFinal ? "" : `is_${componentNameFinal}`;
      let classList = [];
      componentClassName && classList.push(componentClassName), fontFamilyClassName && classList.push(fontFamilyClassName), classNames && classList.push(Object.values(classNames).join(" ")), groupClassName && classList.push(groupClassName), props.className && classList.push(props.className);
      const finalClassName = classList.join(" ");
      if (styleProps.isAnimated && isReactNative) style && (viewProps.style = style), animationDriver?.supportsCSS && (viewProps.className = finalClassName);
      else if (isReactNative) {
        let cnStyles;
        for (const name of finalClassName.split(" ")) cnStyles ||= {
          $$css: true
        }, cnStyles[name] = name;
        viewProps.style = cnStyles ? [...Array.isArray(style) ? style : [style], cnStyles] : [style];
      } else finalClassName && (viewProps.className = finalClassName), style && (viewProps.style = style);
    }
  }
  if (debug === "verbose" && isClient && isDevTools) {
    console.groupEnd(), console.groupCollapsed("ðŸ”¹ getSplitStyles ===>");
    try {
      const logs = {
        ...result,
        className,
        componentState,
        viewProps,
        rulesToInsert,
        parentSplitStyles
      };
      for (const key in logs) log(key, logs[key]);
    } catch {
    }
    console.groupEnd();
  }
  return debug === "profile" && time`split-styles-done`, result;
};
function mergeFlatTransforms(target, flatTransforms) {
  Object.entries(flatTransforms).sort(([a], [b]) => sortString(a, b)).forEach(([key, val]) => {
    mergeTransform(target, key, val, true);
  });
}
function mergeStyle(styleState, key, val, importance, disableNormalize = false, originalVal) {
  const {
    viewProps,
    styleProps,
    staticConfig,
    usedKeys
  } = styleState;
  if ((usedKeys[key] || 0) > importance) return;
  const contextProps = staticConfig.context?.props || staticConfig.parentStaticConfig?.context?.props;
  if (contextProps && key in contextProps) {
    styleState.overriddenContextProps ||= {};
    const originalFromState = styleState.originalContextPropValues?.[key];
    styleState.overriddenContextProps[key] = originalVal ?? originalFromState ?? val;
  }
  if (key in stylePropsTransform) styleState.flatTransforms ||= {}, usedKeys[key] = importance, styleState.flatTransforms[key] = val;
  else {
    const out = isWeb && !disableNormalize && !styleProps.noNormalize ? normalizeValueWithProperty(val, key) : val;
    staticConfig.accept && key in staticConfig.accept ? viewProps[key] = out : (styleState.style ||= {}, usedKeys[key] = importance, styleState.style[key] = // if you dont do this you'll be passing props.transform arrays directly here and then mutating them
    // if theres any flatTransforms later, causing issues (mutating props is bad, in strict mode styles get borked)
    key === "transform" && Array.isArray(out) ? [...out] : out);
  }
}
var getSubStyle = (styleState, subKey, styleIn, avoidMergeTransform) => {
  const {
    staticConfig,
    conf: conf22,
    styleProps
  } = styleState, styleOut = {};
  let originalValues;
  for (let key in styleIn) {
    const val = styleIn[key];
    key = conf22.shorthands[key] || key, !(!staticConfig.isHOC && key in skipProps && !styleProps.noSkip) && propMapper(key, val, styleState, false, (skey, sval, originalVal) => {
      originalVal !== void 0 && (originalValues ||= {}, originalValues[skey] = originalVal), skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : normalizeValueWithProperty(sval, key);
    });
  }
  if (!avoidMergeTransform) {
    if (Array.isArray(styleOut.transform)) {
      const parentTransform = styleState.style?.transform;
      parentTransform && (styleOut.transform = [...parentTransform, ...styleOut.transform]);
    }
    styleState.flatTransforms && mergeFlatTransforms(styleOut, styleState.flatTransforms);
  }
  return styleProps.noNormalize || fixStyles(styleOut), originalValues && styleOriginalValues.set(styleOut, originalValues), styleOut;
};
var useInsertEffectCompat = isWeb ? import_react14.default.useInsertionEffect || useIsomorphicLayoutEffect : () => {
};
var useSplitStyles = (a, b, c, d, e, f, g, h, i, j, k, l) => {
  const res = getSplitStyles(a, b, c, d, e, f, g, h, i, j, k, l);
  return useInsertEffectCompat(() => {
    res && insertStyleRules(res.rulesToInsert);
  }, [res?.rulesToInsert]), res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  {
    const identifier = styleObject[StyleObjectIdentifier];
    shouldInsertStyleRules(identifier) && (updateRules(identifier, styleObject[StyleObjectRules]), rulesToInsert[identifier] = styleObject);
  }
}
function processIDRefList(idRefList) {
  return Array.isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)";
var animatableDefaults = {
  ...Object.fromEntries(Object.entries(tokenCategories.color).map(([k, v]) => [k, defaultColor])),
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
};
var lowercaseHyphenate = (match) => `-${match.toLowerCase()}`;
var hyphenate = (str) => str.replace(/[A-Z]/g, lowercaseHyphenate);
var mergeTransform = (obj, key, val, backwards = false) => {
  typeof obj.transform != "string" && (obj.transform ||= [], obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
};
var mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
var accessibilityRoleToWebRole = {
  adjustable: "slider",
  header: "heading",
  image: "img",
  link: "link",
  none: "presentation",
  summary: "region"
};
function passDownProp(viewProps, key, val, shouldMergeObject = false) {
  if (shouldMergeObject) {
    const next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key], viewProps[key] = next;
  } else viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, isSizeMedia, importanceBump, debugProp, originalVal) {
  const usedKeys = styleState.usedKeys;
  let importance = getMediaImportanceIfMoreImportant(mediaKey, key, styleState, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), debugProp === "verbose" && log(`mergeMediaByImportance ${key} importance usedKey ${usedKeys[key]} next ${importance}`), importance === null) return false;
  if (key in pseudoDescriptors) {
    const descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name;
    if (styleState.componentState[descriptorKey] === false) return false;
    const pseudoOriginalValues = styleOriginalValues.get(value);
    for (const subKey in value) mergeStyle(styleState, subKey, value[subKey], importance, false, pseudoOriginalValues?.[subKey]);
  } else mergeStyle(styleState, key, value, importance, false, originalVal);
  return true;
}
function normalizeStyle2(style) {
  const out = {};
  for (const key in style) {
    const val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty(val, key);
  }
  return isWeb && Array.isArray(out.transform) && (out.transform = transformsToString(out.transform)), fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  const defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues, 1);
}

// ../../node_modules/@tamagui/web/dist/esm/setupHooks.mjs
var hooks = {};
function setupHooks(next) {
  Object.assign(hooks, next);
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/setElementProps.mjs
var setElementProps = (node2) => {
  hooks.setElementProps?.(node2);
};

// ../../node_modules/@tamagui/web/dist/esm/helpers/subscribeToContextGroup.mjs
var subscribeToContextGroup = (props) => {
  const {
    pseudoGroups,
    mediaGroups,
    groupContext
  } = props;
  if (pseudoGroups || mediaGroups) {
    !groupContext && console.debug("No context group found");
    const disposables = /* @__PURE__ */ new Set();
    if (pseudoGroups) for (const name of [...pseudoGroups]) disposables.add(createGroupListener(name, props));
    if (mediaGroups) for (const name of [...mediaGroups]) disposables.add(createGroupListener(name, props));
    return () => {
      disposables.forEach((d) => d());
    };
  }
};
var createGroupListener = (name, {
  setStateShallow,
  pseudoGroups,
  mediaGroups,
  groupContext
}) => {
  const parent = groupContext?.[name];
  if (!parent) return () => {
  };
  const dispose2 = parent.subscribe(({
    layout,
    pseudo
  }) => {
    setStateShallow((prev) => {
      let didChange = false;
      const group = prev.group?.[name] || {
        pseudo: {},
        media: {}
      };
      if (pseudo && pseudoGroups?.has(name)) group.pseudo ||= {}, mergeIfNotShallowEqual(group.pseudo, pseudo) !== group.pseudo && (Object.assign(group.pseudo, pseudo), didChange = true);
      else if (layout && mediaGroups) {
        group.media ||= {};
        const mediaState2 = getMediaState(mediaGroups, layout), next = mergeIfNotShallowEqual(group.media, mediaState2);
        next !== group.media && (Object.assign(group.media, next), didChange = true);
      }
      return didChange ? {
        group: {
          ...prev.group,
          [name]: group
        }
      } : prev;
    });
  });
  return () => {
    dispose2(), setStateShallow({
      group: {}
    });
  };
};

// ../../node_modules/@tamagui/web/dist/esm/helpers/wrapStyleTags.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
function getStyleTags(styles) {
  if (IS_REACT_19 && styles.length) return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, {
    children: styles.map((styleObject) => {
      const identifier = styleObject[StyleObjectIdentifier];
      return (0, import_jsx_runtime6.jsx)("style", {
        href: `t_${identifier}`,
        precedence: "default",
        suppressHydrationWarning: true,
        children: styleObject[StyleObjectRules].join(`
`)
      }, identifier);
    })
  });
}

// ../../node_modules/@tamagui/web/dist/esm/hooks/useComponentState.mjs
var import_react15 = __toESM(require_react(), 1);
var useComponentState = (props, animationDriver, staticConfig, config) => {
  const isHydrated = useDidFinishSSR(), needsHydration = !useIsClientOnly(), useAnimations = animationDriver?.isStub ? void 0 : animationDriver?.useAnimations, {
    isHOC
  } = staticConfig, stateRef = (0, import_react15.useRef)(
    // performance: avoid creating object every render
    void 0
  );
  stateRef.current || (stateRef.current = {
    startedUnhydrated: needsHydration && !isHydrated
  });
  const hasAnimationProp = !!(!isHOC && "animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSS = animationDriver?.supportsCSS, curStateRef = stateRef.current;
  !needsHydration && hasAnimationProp && (curStateRef.hasAnimated = true);
  const willBeAnimatedClient = !!(!!(hasAnimationProp && !isHOC && useAnimations) || curStateRef.hasAnimated), willBeAnimated = !isServer && willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = true);
  const {
    disableClassName
  } = props, presence = !isHOC && willBeAnimated && props.animatePresence !== false && animationDriver?.usePresence?.() || null, presenceState = presence?.[2], isExiting = presenceState?.isPresent === false, isEntering = presenceState?.isPresent === true && presenceState.initial !== false, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated && (animationDriver?.isReactNative || !supportsCSS), initialState = !isHOC && (hasEnterStyle || isEntering || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName) ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    hasEnterStyle || isEntering ? defaultComponentStateShouldEnter : defaultComponentState
  ) : defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  const states2 = (0, import_react15.useState)(initialState), state = props.forceStyle ? {
    ...states2[0],
    [props.forceStyle]: true
  } : states2[0], setState = states2[1];
  let isAnimated = willBeAnimated;
  isWeb && hasAnimationThatNeedsHydrate && !staticConfig.isHOC && !isHydrated && (isAnimated = false, curStateRef.willHydrate = true), disabled !== state.disabled && (disabled && Object.assign(state, defaultComponentStateMounted), state.disabled = disabled, setState((_) => ({
    ...state
  })));
  const groupName = props.group, setStateShallow = useCreateShallowSetState(setState, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    props.debug === "verbose" && console.warn(`has presenceState ${JSON.stringify(presenceState)}`);
    const {
      enterVariant,
      exitVariant,
      enterExitVariant,
      custom
    } = presenceState;
    isObj(custom) && Object.assign(props, custom);
    const exv = exitVariant ?? enterExitVariant, env = enterVariant ?? enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? (props.debug === "verbose" && console.warn(`Animating presence ENTER "${env}"`), props[env] = true) : isExiting && exv && (props.debug === "verbose" && console.warn(`Animating presence EXIT "${exv}"`), props[exv] = exitVariant !== enterExitVariant);
  }
  let noClass = !isWeb || !!props.forceStyle;
  if (!isHydrated) noClass = false;
  else if (isWeb && isHydrated) {
    const isAnimatedAndHydrated = isAnimated && isHydrated, isClassNameDisabled = !staticConfig.acceptsClassName && (config.disableSSR || !state.unmounted), isDisabledManually = disableClassName && !state.unmounted;
    (isAnimatedAndHydrated && !animationDriver?.classNameAnimation || isDisabledManually || isClassNameDisabled) && (noClass = true, props.debug === "verbose" && log("avoiding className", {
      isAnimatedAndHydrated,
      isDisabledManually,
      isClassNameDisabled
    }));
  }
  return {
    startedUnhydrated: curStateRef.startedUnhydrated,
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSS,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some((k) => {
    const val = style[k];
    return val && typeof val == "object" && "_animation" in val;
  });
}
var isDisabled = (props) => props.disabled || props.passThrough || props.accessibilityState?.disabled || props["aria-disabled"] || props.accessibilityDisabled || false;

// ../../node_modules/@tamagui/web/dist/esm/views/Slot.mjs
var import_react16 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var is19 = import_react16.version.startsWith("19.");
var Slot = (0, import_react16.memo)((0, import_react16.forwardRef)(function(props, forwardedRef) {
  const {
    children,
    ...slotProps
  } = props;
  if ((0, import_react16.isValidElement)(children)) {
    const mergedProps = mergeSlotProps(children, slotProps);
    return (0, import_react16.cloneElement)(children, children.type.avoidForwardRef ? mergedProps : {
      ...mergedProps,
      ref: composeRefs(forwardedRef, is19 ? children.props.ref : children.ref)
    });
  }
  return import_react16.Children.count(children) > 1 ? import_react16.Children.only(null) : null;
}));
var Slottable = ({
  children
}) => (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, {
  children
});
Slottable.displayName = "Slottable";
var pressMap = isWeb ? {
  onPress: "onClick",
  onPressOut: "onMouseUp",
  onPressIn: "onMouseDown"
} : {};
function mergeSlotProps(child, slotProps) {
  const childProps = child.props, overrideProps = {
    ...childProps
  }, isHTMLChild = typeof child.type == "string";
  if (isHTMLChild) for (const key in pressMap) key in slotProps && (slotProps[pressMap[key]] = slotProps[key], delete slotProps[key]);
  for (let propName in childProps) {
    const slotPropValue = slotProps[propName], childPropValue = childProps[propName];
    isHTMLChild && propName in pressMap && (propName = pressMap[propName], delete overrideProps[propName]), handleRegex.test(propName) ? overrideProps[propName] = composeEventHandlers(childPropValue, slotPropValue) : propName === "style" ? overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    } : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
var handleRegex = /^on[A-Z]/;

// ../../node_modules/@tamagui/web/dist/esm/createComponent.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var time2;
var debugKeyListeners;
var startVisualizer;
var componentSetStates = /* @__PURE__ */ new Set();
var avoidReRenderKeys = /* @__PURE__ */ new Set(["hover", "press", "pressIn", "group", "focus", "focusWithin", "media", "group"]);
if (typeof window < "u") {
  const cancelPresses = () => {
    componentSetStates.forEach((setState) => setState((prev) => prev.press || prev.pressIn ? {
      ...prev,
      press: false,
      pressIn: false
    } : prev)), componentSetStates.clear();
  }, cancelTouches = () => {
    componentSetStates.forEach((setState) => setState((prev) => prev.press || prev.pressIn || prev.hover ? {
      ...prev,
      press: false,
      pressIn: false,
      hover: false
    } : prev)), componentSetStates.clear();
  };
  addEventListener("mouseup", cancelPresses), addEventListener("touchend", cancelTouches), addEventListener("touchcancel", cancelTouches), startVisualizer = () => {
    const devVisualizerConfig = devConfig?.visualizer;
    if (devVisualizerConfig && !globalThis.__tamaguiDevVisualizer) {
      let show = function(val) {
        clearTimeout(tm), isShowing = val, debugKeyListeners?.forEach((l) => l(val)), !val && resizeListener && (window.removeEventListener("resize", resizeListener), resizeListener = null);
      }, cancelShow = function() {
        clearTimeout(tm), resizeListener && (window.removeEventListener("resize", resizeListener), resizeListener = null);
      };
      globalThis.__tamaguiDevVisualizer = true, debugKeyListeners = /* @__PURE__ */ new Set();
      let tm, isShowing = false, resizeListener = null;
      const options = {
        key: "Alt",
        delay: 800,
        ...typeof devVisualizerConfig == "object" ? devVisualizerConfig : {}
      };
      window.addEventListener("blur", () => {
        show(false);
      }), window.addEventListener("keydown", ({
        key,
        metaKey,
        defaultPrevented
      }) => {
        clearTimeout(tm), !defaultPrevented && (metaKey || key === options.key && (resizeListener || (resizeListener = () => cancelShow(), window.addEventListener("resize", resizeListener)), tm = setTimeout(() => {
          show(true);
        }, options.delay)));
      }), window.addEventListener("keyup", ({
        defaultPrevented
      }) => {
        defaultPrevented || (cancelShow(), isShowing && show(false));
      });
    }
  };
}
var BaseText;
var BaseView;
var lastInteractionWasKeyboard = {
  value: false
};
var lastInteractionWasTouch = {
  value: false
};
isWeb && typeof document < "u" && (document.addEventListener("keydown", () => {
  lastInteractionWasKeyboard.value || (lastInteractionWasKeyboard.value = true);
}), document.addEventListener("mousedown", () => {
  lastInteractionWasKeyboard.value && (lastInteractionWasKeyboard.value = false);
}), document.addEventListener("mousemove", () => {
  lastInteractionWasKeyboard.value && (lastInteractionWasKeyboard.value = false), lastInteractionWasTouch.value = false;
}), document.addEventListener("touchstart", () => {
  lastInteractionWasTouch.value = true;
}));
function createComponent(staticConfig) {
  const {
    componentName
  } = staticConfig;
  let config = null, defaultProps = staticConfig.defaultProps;
  onConfiguredOnce((conf4) => {
    if (config = conf4, componentName) {
      const defaultForComponent = conf4.defaultProps?.[componentName];
      defaultForComponent && (defaultProps = {
        ...defaultForComponent,
        ...defaultProps
      });
    }
  });
  const {
    Component,
    isText,
    isZStack,
    isHOC
  } = staticConfig;
  staticConfig.defaultProps?.debug && process.env.IS_STATIC !== "is_static" && log(`ðŸ› [${componentName || "Component"}]`, {
    staticConfig,
    defaultProps,
    defaultPropsKeyOrder: defaultProps ? Object.keys(defaultProps) : []
  });
  const component = import_react17.default.forwardRef((propsIn, forwardedRef) => {
    const internalID = true ? import_react17.default.useId() : "";
    startVisualizer && (startVisualizer(), startVisualizer = void 0), false;
    const {
      context,
      isReactNative
    } = staticConfig, debugProp = propsIn.debug, styledContextValue = context ? import_react17.default.useContext(context) : void 0;
    let overriddenContextProps = null;
    const componentContext = import_react17.default.useContext(ComponentContext), hasTextAncestor = !!(isWeb && isText && componentContext.inText);
    !process.env.TAMAGUI_IS_CORE_NODE && true && debugProp === "profile" && !time2 && (time2 = (init_esm(), __toCommonJS(esm_exports2)).timer().start(), globalThis.time = time2), time2 && time2`non-tamagui time (ignore)`;
    let props = propsIn;
    if (styledContextValue || defaultProps) {
      let effectiveDefaults = defaultProps;
      isText && hasTextAncestor && defaultProps && (effectiveDefaults = {
        ...defaultProps
      }, effectiveDefaults.fontFamily === "unset" && (effectiveDefaults.fontFamily = "inherit"), effectiveDefaults.whiteSpace === "pre-wrap" && (effectiveDefaults.whiteSpace = "inherit"), effectiveDefaults.color || (effectiveDefaults.color = "inherit"), effectiveDefaults.letterSpacing || (effectiveDefaults.letterSpacing = "inherit"), effectiveDefaults.textTransform || (effectiveDefaults.textTransform = "inherit"));
      const [nextProps, overrides] = mergeComponentProps(effectiveDefaults, styledContextValue, propsIn);
      nextProps && (props = nextProps), overriddenContextProps = overrides;
    }
    const componentName2 = props.componentName || staticConfig.componentName;
    isClient && import_react17.default.useEffect(() => {
      let node2, overlay = null;
      const remove = () => {
        if (overlay) try {
          overlay.parentNode?.removeChild(overlay), overlay = null;
        } catch {
        }
      }, debugVisualizerHandler = (show = false) => {
        if (node2 = stateRef.current.host, !!node2) if (show) {
          overlay || (overlay = document.createElement("span"), overlay.style.inset = "0px", overlay.style.zIndex = "1000000", overlay.style.position = "absolute", overlay.style.borderColor = "red", overlay.style.borderWidth = "1px", overlay.style.borderStyle = "dotted");
          const dataAt = node2.getAttribute("data-at") || "", dataIn = node2.getAttribute("data-in") || "", tooltip = document.createElement("span");
          tooltip.style.position = "absolute", tooltip.style.top = "0px", tooltip.style.left = "0px", tooltip.style.padding = "3px", tooltip.style.background = "rgba(0,0,0,0.75)", tooltip.style.color = "rgba(255,255,255,1)", tooltip.style.fontSize = "12px", tooltip.style.lineHeight = "12px", tooltip.style.fontFamily = "monospace", tooltip.innerText = `${componentName2 || ""} ${dataAt} ${dataIn}`.trim(), overlay.appendChild(tooltip), node2.appendChild(overlay);
        } else remove();
      };
      return debugKeyListeners ||= /* @__PURE__ */ new Set(), debugKeyListeners.add(debugVisualizerHandler), () => {
        remove(), debugKeyListeners?.delete(debugVisualizerHandler);
      };
    }, [componentName2]);
    const groupContextParent = import_react17.default.useContext(GroupContext), animationDriver = componentContext.animationDriver, useAnimations = animationDriver?.useAnimations, componentState = useComponentState(props, animationDriver?.isStub ? null : animationDriver, staticConfig, config), {
      disabled,
      groupName,
      hasAnimationProp,
      hasEnterStyle,
      isAnimated,
      isExiting,
      isHydrated,
      presence,
      presenceState,
      setState,
      noClass,
      state,
      stateRef,
      supportsCSS,
      willBeAnimated,
      willBeAnimatedClient,
      startedUnhydrated
    } = componentState;
    hasAnimationProp && animationDriver?.avoidReRenders && useIsomorphicLayoutEffect(() => {
      const pendingState = stateRef.current.nextState;
      pendingState && (stateRef.current.nextState = void 0, componentState.setStateShallow(pendingState));
    });
    const allGroupContexts = (0, import_react17.useMemo)(() => {
      if (!groupName || props.passThrough) return groupContextParent;
      const listeners2 = /* @__PURE__ */ new Set();
      return stateRef.current.group?.listeners?.clear(), stateRef.current.group = {
        listeners: listeners2,
        emit(state2) {
          listeners2.forEach((l) => l(state2));
        },
        subscribe(cb) {
          return listeners2.add(cb), listeners2.size === 1 && setStateShallow({
            hasDynGroupChildren: true
          }), () => {
            listeners2.delete(cb), listeners2.size === 0 && setStateShallow({
              hasDynGroupChildren: false
            });
          };
        }
      }, {
        ...groupContextParent,
        [groupName]: {
          state: {
            pseudo: defaultComponentStateMounted
          },
          subscribe: (listener) => {
            const dispose2 = stateRef.current.group?.subscribe(listener);
            return () => {
              dispose2?.();
            };
          }
        }
      };
    }, [stateRef, groupName, groupContextParent]);
    let setStateShallow = componentState.setStateShallow;
    time2 && time2`use-state`;
    const isTaggable = !Component || typeof Component == "string", tagProp = props.tag, element = isWeb && isTaggable && tagProp || Component, BaseTextComponent = BaseText || element || "span", BaseViewComponent = BaseView || element || (hasTextAncestor ? "span" : "div");
    let elementType = isText ? BaseTextComponent : BaseViewComponent;
    animationDriver && isAnimated && // this should really be behind another prop as it's not really related to
    // "needsWebStyles" basically with motion we just animate a plain div, but
    // we still have animated.View/Text for Sheet which wants to control
    // things declaratively
    !animationDriver.needsWebStyles && (elementType = animationDriver[isText ? "Text" : "View"] || elementType);
    const disableTheme = props["data-disable-theme"] || isHOC;
    time2 && time2`theme-props`, props.themeShallow && (stateRef.current.themeShallow = true);
    const themeStateProps = {
      componentName: componentName2,
      disable: disableTheme,
      shallow: stateRef.current.themeShallow,
      debug: debugProp
    };
    if ("themeInverse" in props && (themeStateProps.inverse = props.themeInverse), "theme" in props && (themeStateProps.name = props.theme), typeof stateRef.current.isListeningToTheme == "boolean" && (themeStateProps.needsUpdate = () => !!stateRef.current.isListeningToTheme), debugProp && debugProp !== "profile") {
      const name = `${componentName2 || Component?.displayName || Component?.name || "[Unnamed Component]"}`, type = (hasEnterStyle ? "(hasEnter)" : " ") + (isAnimated ? "(animated)" : " ") + (isReactNative ? "(rnw)" : " ") + (noClass ? "(noClass)" : " ") + (state.press || state.pressIn ? "(PRESSED)" : " ") + (state.hover ? "(HOVERED)" : " ") + (state.focus ? "(FOCUSED)" : " ") + (state.focusWithin ? "(WITHIN FOCUSED)" : " ") + (presenceState?.isPresent === false ? "(EXIT)" : ""), dataIs = propsIn["data-is"] || "", banner = `<${name} /> ${internalID} ${dataIs ? ` ${dataIs}` : ""} ${type.trim()} (hydrated: ${isHydrated}) (unmounted: ${state.unmounted})`, ch = propsIn.children;
      let childLog = typeof ch == "string" ? ch.length > 4 ? ch.slice(0, 4) + "..." : ch : "";
      childLog.length && (childLog = `(children: ${childLog})`), isWeb ? (console.info(`%c ${banner}`, "background: green; color: white;"), isServer ? log({
        noClass,
        isAnimated,
        isWeb,
        supportsCSS
      }) : (console.groupEnd(), console.groupCollapsed(`${childLog} [inspect props, state, context ðŸ‘‡]`), log("props in:", propsIn), log("final props:", props, Object.keys(props)), log({
        state,
        staticConfig,
        elementType,
        themeStateProps
      }), log({
        context,
        overriddenContextProps,
        componentContext
      }), log({
        presence,
        isAnimated,
        isHOC,
        hasAnimationProp,
        useAnimations
      }), console.groupEnd())) : (console.info(`

------------------------------
${banner}
------------------------------
`), log("children:", props.children), log({
        overriddenContextProps,
        styledContextValue
      }), log({
        noClass,
        isAnimated,
        isWeb,
        supportsCSS
      }));
    }
    time2 && time2`pre-theme-media`;
    const [theme, themeState] = useThemeWithState(themeStateProps);
    time2 && time2`theme`, elementType = Component || elementType;
    const isStringElement = typeof elementType == "string", mediaState2 = useMedia(componentContext, debugProp);
    setDidGetVariableValue(false), time2 && time2`media`;
    const resolveValues = (
      // if HOC + mounted + has animation prop, resolve as value so it passes non-variable to child
      isAnimated && !supportsCSS || isHOC && state.unmounted == false && hasAnimationProp ? "value" : "auto"
    ), styleProps = {
      mediaState: mediaState2,
      noClass,
      resolveValues,
      isExiting,
      isAnimated,
      willBeAnimated,
      styledContext: styledContextValue
    }, themeName = themeState?.name || "";
    time2 && time2`split-styles-prepare`;
    const splitStyles = useSplitStyles(props, staticConfig, theme, themeName, state, styleProps, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), isPassthrough = !splitStyles;
    let contextForOverride = staticConfig.context;
    if (splitStyles?.overriddenContextProps) {
      const contextForProps = staticConfig.context || staticConfig.parentStaticConfig?.context;
      if (contextForProps) {
        for (const key in splitStyles.overriddenContextProps) overriddenContextProps ||= {}, overriddenContextProps[key] = splitStyles.overriddenContextProps[key];
        staticConfig.context || (contextForOverride = contextForProps);
      }
    }
    const groupContext = groupName && allGroupContexts?.[groupName] || null;
    if (!isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal") {
      const groupState = groupContext?.state;
      groupState && groupState.layout === void 0 && (splitStyles.style?.width || splitStyles.style?.height) && (groupState.layout = {
        width: fromPx(splitStyles.style.width),
        height: fromPx(splitStyles.style.height)
      });
    }
    if (!isPassthrough && (hasAnimationProp || groupName) && animationDriver?.avoidReRenders) {
      let updateGroupListeners = function() {
        const updatedState = stateRef.current.nextState;
        if (groupContext) {
          const {
            group,
            hasDynGroupChildren,
            unmounted,
            animation,
            ...childrenGroupState
          } = updatedState;
          notifyGroupSubscribers(groupContext, stateRef.current.group || null, childrenGroupState);
        }
      };
      const ogSetStateShallow = setStateShallow;
      stateRef.current.updateStyleListener = () => {
        const updatedState = stateRef.current.nextState || state, mediaState22 = stateRef.current.nextMedia, nextStyles = getSplitStyles(props, staticConfig, theme, themeName, updatedState, mediaState22 ? {
          ...styleProps,
          mediaState: mediaState22
        } : styleProps, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), useStyleListener = stateRef.current.useStyleListener;
        useStyleListener?.(nextStyles?.style || {});
      }, componentContext.mediaEmit ||= (next) => {
        stateRef.current.nextMedia = next, stateRef.current.updateStyleListener?.();
      }, stateRef.current.setStateShallow = (nextOrGetNext) => {
        const prev = stateRef.current.nextState || state, next = typeof nextOrGetNext == "function" ? nextOrGetNext(prev) : nextOrGetNext;
        if (next === prev || isEqualShallow(prev, next)) return;
        const canAvoidReRender = Object.keys(next).every((key) => avoidReRenderKeys.has(key)), updatedState = {
          ...prev,
          ...next
        };
        stateRef.current.nextState = updatedState, canAvoidReRender ? (debugProp && debugProp !== "profile" && (console.groupCollapsed("[âš¡ï¸] avoid setState", componentName2, next, {
          updatedState,
          props
        }), console.info(stateRef.current.host), console.groupEnd()), updateGroupListeners(), stateRef.current.updateStyleListener?.()) : (debugProp && debugProp !== "profile" && console.info("[ðŸŒ] re-render", {
          canAvoidReRender,
          next
        }), ogSetStateShallow(next));
      }, setStateShallow = (state2) => {
        stateRef.current.setStateShallow?.(state2);
      };
    }
    time2 && time2`split-styles`, splitStyles && (props.group && props.untilMeasured === "hide" && !stateRef.current.hasMeasured && (splitStyles.style ||= {}, splitStyles.style.opacity = 0), splitStyles.dynamicThemeAccess != null && (stateRef.current.isListeningToTheme = splitStyles.dynamicThemeAccess));
    const hasRuntimeMediaKeys = splitStyles?.hasMedia && splitStyles.hasMedia !== true, shouldListenForMedia = didGetVariableValue() || hasRuntimeMediaKeys || noClass && splitStyles?.hasMedia === true, mediaListeningKeys = hasRuntimeMediaKeys ? splitStyles.hasMedia : null;
    debugProp === "verbose" && console.info("useMedia() createComponent", shouldListenForMedia, mediaListeningKeys), setMediaShouldUpdate(componentContext, shouldListenForMedia, mediaListeningKeys);
    const {
      viewProps: viewPropsIn,
      pseudos,
      style: splitStylesStyle,
      classNames,
      space,
      pseudoGroups,
      mediaGroups
    } = splitStyles || {}, propsWithAnimation = props, {
      asChild,
      children,
      themeShallow,
      spaceDirection: _spaceDirection,
      onPress,
      onLongPress,
      onPressIn,
      onPressOut,
      onHoverIn,
      onHoverOut,
      onMouseUp,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      separator,
      // ignore from here on out
      passThrough,
      forceStyle: _forceStyle,
      // @ts-ignore  for next/link compat etc
      onClick,
      theme: _themeProp,
      ...nonTamaguiProps
    } = viewPropsIn || {};
    let viewProps = nonTamaguiProps;
    !isTaggable && props.forceStyle && (viewProps.forceStyle = props.forceStyle), isHOC && (typeof _themeProp < "u" && (viewProps.theme = _themeProp), typeof passThrough < "u" && (viewProps.passThrough = passThrough)), tagProp && elementType.acceptTagProp && (viewProps.tag = tagProp);
    let animationStyles;
    const shouldUseAnimation = (
      // if it supports css vars we run it on server too to get matching initial style
      (supportsCSS ? willBeAnimatedClient : willBeAnimated) && useAnimations && !isHOC
    );
    let animatedRef;
    if (shouldUseAnimation) {
      const useStyleEmitter = animationDriver?.avoidReRenders ? (listener) => {
        stateRef.current.useStyleListener = listener;
      } : void 0, animations = useAnimations({
        props: propsWithAnimation,
        // if hydrating, send empty style
        style: splitStylesStyle || {},
        // @ts-ignore
        styleState: splitStyles,
        useStyleEmitter,
        presence,
        componentState: state,
        styleProps,
        theme,
        pseudos: pseudos || null,
        staticConfig,
        stateRef
      });
      animations && (animations.ref && (animatedRef = animations.ref), isHydrated && animations && (animationStyles = animations.style, viewProps.style = animationStyles, animations.className && (viewProps.className = `${state.unmounted === "should-enter" ? "t_unmounted " : ""}${viewProps.className || ""} ${animations.className}`))), time2 && time2`animations`;
    }
    props.untilMeasured && !props.group && console.warn(`You set the untilMeasured prop without setting group. This doesn't work, be sure to set untilMeasured on the parent that sets group, not the children that use the $group- prop.

If you meant to do this, you can disable this warning - either change untilMeasured and group at the same time, or do group={conditional ? 'name' : undefined}`), time2 && time2`destructure`, !isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal" && (nonTamaguiProps.onLayout = composeEventHandlers(nonTamaguiProps.onLayout, (e) => {
      const layout = e.nativeEvent.layout;
      groupContext.state.layout = layout, stateRef.current.group?.emit({
        layout
      }), !stateRef.current.hasMeasured && props.untilMeasured === "hide" && setState((prev) => ({
        ...prev
      })), stateRef.current.hasMeasured = true;
    })), viewProps = hooks.usePropsTransform?.(elementType, nonTamaguiProps, stateRef, stateRef.current.willHydrate) || nonTamaguiProps, stateRef.current.composedRef || (stateRef.current.composedRef = composeRefs((x) => stateRef.current.host = x, forwardedRef, setElementProps, animatedRef)), viewProps.ref = stateRef.current.composedRef, !isReactNative && !isText && isWeb && !isHOC && import_react17.default.Children.toArray(props.children).forEach((item) => {
      typeof item == "string" && item !== `
` && console.error(`Unexpected text node: ${item}. A text node cannot be a child of a <${staticConfig.componentName || propsIn.tag || "View"}>.`, props);
    }), time2 && time2`events-hooks`;
    const unPress = () => {
      setStateShallow({
        press: false,
        pressIn: false
      });
    };
    isWeb && useIsomorphicLayoutEffect(() => {
      if (debugProp === "verbose") {
        let cssStyleDeclarationToObject = function(style) {
          const styleObject = {};
          for (let i = 0; i < style.length; i++) {
            let prop = style[i];
            styleObject[prop] = style.getPropertyValue(prop);
          }
          return styleObject;
        };
        const computed = stateRef.current.host ? cssStyleDeclarationToObject(getComputedStyle(stateRef.current.host)) : {};
        console.groupCollapsed(`Rendered > (opacity: ${computed.opacity})`), console.warn(stateRef.current.host), console.warn(computed), console.groupEnd();
      }
    }), useIsomorphicLayoutEffect(() => {
      if (state.unmounted === true && hasEnterStyle) {
        setStateShallow({
          unmounted: "should-enter"
        });
        return;
      }
      let tm;
      if (state.unmounted) {
        if (animationDriver?.supportsCSS || isAndroid) return tm = setTimeout(() => {
          setStateShallow({
            unmounted: false
          });
        }), () => clearTimeout(tm);
        setStateShallow({
          unmounted: false
        });
        return;
      }
      return () => {
        componentSetStates.delete(setState);
      };
    }, [state.unmounted, disabled]), useIsomorphicLayoutEffect(() => {
      if (!disabled && !(!pseudoGroups && !mediaGroups) && allGroupContexts) return subscribeToContextGroup({
        groupContext: allGroupContexts,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }, [allGroupContexts, disabled, pseudoGroups ? objectIdentityKey(pseudoGroups) : 0, mediaGroups ? objectIdentityKey(mediaGroups) : 0]);
    const groupEmitter = stateRef.current.group;
    useIsomorphicLayoutEffect(() => {
      !groupContext || !groupEmitter || notifyGroupSubscribers(groupContext, groupEmitter, state);
    }, [groupContext, groupEmitter, state]);
    const runtimePressStyle = !disabled && noClass && pseudos?.pressStyle, runtimeFocusStyle = !disabled && noClass && pseudos?.focusStyle, runtimeFocusVisibleStyle = !disabled && noClass && pseudos?.focusVisibleStyle, attachFocus = !!(runtimePressStyle || runtimeFocusStyle || runtimeFocusVisibleStyle || onFocus || onBlur || componentContext.setParentFocusState), hasDynamicGroupChildren = !!(groupName && state.hasDynGroupChildren), attachPress = !!(hasDynamicGroupChildren || runtimePressStyle || onPress || onPressOut || onPressIn || onMouseDown || onMouseUp || onLongPress || onClick || pseudos?.focusVisibleStyle), runtimeHoverStyle = !disabled && noClass && pseudos?.hoverStyle, needsHoverState = !!(hasDynamicGroupChildren || runtimeHoverStyle), attachHover = isWeb && !!(hasDynamicGroupChildren || needsHoverState || onMouseEnter || onMouseLeave), shouldAttach = !disabled && !props.asChild && !!(attachFocus || attachPress || attachHover || runtimePressStyle || runtimeHoverStyle || runtimeFocusStyle), needsPressState = !!(hasDynamicGroupChildren || runtimePressStyle);
    time2 && time2`events-setup`, debugProp === "verbose" && log("ðŸª© events()", {
      runtimeFocusStyle,
      runtimePressStyle,
      runtimeHoverStyle,
      runtimeFocusVisibleStyle,
      attachPress,
      attachFocus,
      attachHover,
      shouldAttach,
      needsHoverState,
      pseudos
    });
    const events = shouldAttach ? {
      onPressOut: attachPress ? (e) => {
        unPress(), onPressOut?.(e), onMouseUp?.(e);
      } : void 0,
      ...(attachHover || attachPress) && {
        onMouseEnter: (e) => {
          const next = {};
          needsHoverState && !lastInteractionWasTouch.value && (next.hover = true), needsPressState && state.pressIn && (next.press = true), setStateShallow(next), onHoverIn?.(e), onMouseEnter?.(e);
        },
        onMouseLeave: (e) => {
          const next = {};
          needsHoverState && (next.hover = false), needsPressState && (next.press = false, next.pressIn = false), setStateShallow(next), onHoverOut?.(e), onMouseLeave?.(e);
        }
      },
      onPressIn: attachPress ? (e) => {
        needsPressState && setStateShallow({
          press: true,
          pressIn: true
        }), onPressIn?.(e), onMouseDown?.(e), isWeb && componentSetStates.add(setState);
      } : void 0,
      onPress: attachPress ? (e) => {
        unPress(), isWeb && onClick?.(e), onPress?.(e), onLongPress?.(e);
      } : void 0,
      ...attachFocus && {
        onFocus: (e) => {
          const next = {};
          componentContext.setParentFocusState && (next.focusWithin = true), pseudos?.focusVisibleStyle && lastInteractionWasKeyboard.value ? next.focusVisible = true : next.focus = true, setStateShallow(next), onFocus?.(e);
        },
        onBlur: (e) => {
          componentContext.setParentFocusState && componentContext.setParentFocusState({
            focusWithin: false
          }), setStateShallow({
            focus: false,
            focusVisible: false,
            focusWithin: false
          }), onBlur?.(e);
        }
      }
    } : null;
    events && !isReactNative && Object.assign(viewProps, getWebEvents(events)), time2 && time2`events`, debugProp === "verbose" && log("events", {
      events,
      attachHover,
      attachPress
    }), hooks.useEvents?.(viewProps, events, splitStyles, setStateShallow, staticConfig);
    const direction = props.spaceDirection || "both";
    time2 && time2`hooks`;
    let content = !children || asChild || !splitStyles ? children : spacedChildren({
      separator,
      children,
      space,
      direction,
      isZStack,
      debug: debugProp
    });
    if (asChild) {
      elementType = Slot;
      {
        const passEvents = getWebEvents({
          onPress,
          onLongPress,
          onPressIn,
          onPressOut,
          onMouseUp,
          onMouseDown,
          onMouseEnter,
          onMouseLeave
        }, asChild === "web" || asChild === "except-style-web");
        Object.assign(viewProps, passEvents);
      }
    }
    time2 && time2`spaced-as-child`, isPassthrough && (content = propsIn.children, elementType = BaseViewComponent, viewProps = {
      style: {
        display: "contents"
      }
    });
    let useChildrenResult;
    hooks.useChildren && (useChildrenResult = hooks.useChildren(elementType, content, viewProps)), time2 && time2`use-children`, useChildrenResult ? content = useChildrenResult : content = import_react17.default.createElement(elementType, viewProps, content);
    const ResetPresence2 = config?.animations?.ResetPresence, needsReset = !!// not when passing down to child
    (!asChild && // not when passThrough
    splitStyles && // not when HOC
    !isHOC && ResetPresence2 && willBeAnimated && (hasEnterStyle || presenceState)), hasEverReset = stateRef.current.hasEverResetPresence;
    if (needsReset && !hasEverReset && (stateRef.current.hasEverResetPresence = true), (needsReset || hasEverReset) && ResetPresence2 && (content = (0, import_jsx_runtime8.jsx)(ResetPresence2, {
      disabled: !needsReset,
      children: content
    })), time2 && time2`create-element`, "focusWithinStyle" in propsIn && (content = (0, import_jsx_runtime8.jsx)(ComponentContext.Provider, {
      ...componentContext,
      setParentFocusState: setStateShallow,
      children: content
    })), "group" in props && (content = (0, import_jsx_runtime8.jsx)(GroupContext.Provider, {
      value: allGroupContexts,
      children: content
    })), isText && !hasTextAncestor && (content = (0, import_jsx_runtime8.jsx)(ComponentContext.Provider, {
      ...componentContext,
      inText: true,
      children: content
    })), time2 && time2`group-context`, content = disableTheme || !splitStyles ? content : getThemedChildren(themeState, content, themeStateProps, false, stateRef), time2 && time2`themed-children`, isReactNative && !asChild && (content = (0, import_jsx_runtime8.jsx)("span", {
      className: "_dsp_contents",
      ...!isPassthrough && isHydrated && events && getWebEvents(events),
      children: content
    })), overriddenContextProps && contextForOverride) {
      const Provider = contextForOverride.Provider;
      for (const key in styledContextValue) key in overriddenContextProps || (overriddenContextProps[key] = styledContextValue[key]);
      debugProp && console.info("overriddenContextProps", overriddenContextProps), content = (0, import_jsx_runtime8.jsx)(Provider, {
        __disableMergeDefaultValues: true,
        ...overriddenContextProps,
        children: content
      });
    }
    if (time2 && time2`context-override`, startedUnhydrated && splitStyles && (content = (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, {
      children: [content, isHydrated ? null : getStyleTags(Object.values(splitStyles.rulesToInsert))]
    })), time2 && time2`style-tags`, debugProp && debugProp !== "profile") {
      const title = `render <${typeof elementType == "string" ? elementType : "Component"} /> (${internalID}) with props`;
      if (isWeb) {
        console.groupCollapsed(title);
        try {
          log("viewProps", viewProps), log("children", content), typeof window < "u" && log({
            propsIn,
            props,
            attachPress,
            animationStyles,
            classNames,
            content,
            defaultProps,
            elementType,
            events,
            isAnimated,
            hasRuntimeMediaKeys,
            isStringElement,
            mediaListeningKeys,
            pseudos,
            shouldAttach,
            noClass,
            shouldListenForMedia,
            splitStyles,
            splitStylesStyle,
            state,
            stateRef,
            staticConfig,
            styleProps,
            themeState,
            viewProps,
            willBeAnimated,
            startedUnhydrated
          });
        } catch {
        } finally {
          console.groupEnd();
        }
      } else {
        log(title), log("state: ", state), isDevTools && log("viewProps", viewProps), log("final styles:");
        for (const key in splitStylesStyle) log(key, splitStylesStyle[key]);
      }
      if (debugProp === "break") debugger;
    }
    return time2 && (time2`rest`, globalThis.willPrint || (globalThis.willPrint = true, setTimeout(() => {
      delete globalThis.willPrint, time2.print(), time2 = null;
    }, 50))), content;
  });
  function notifyGroupSubscribers(groupContext, groupEmitter, pseudo) {
    if (!groupContext || !groupEmitter) return;
    const nextState = {
      ...groupContext.state,
      pseudo
    };
    groupEmitter.emit(nextState), groupContext.state = nextState;
  }
  staticConfig.componentName && (component.displayName = staticConfig.componentName);
  let res = component;
  (process.env.TAMAGUI_FORCE_MEMO || staticConfig.memo) && (res = import_react17.default.memo(res)), res.staticConfig = staticConfig;
  function extendStyledConfig(extended) {
    return {
      ...staticConfig,
      ...extended,
      neverFlatten: true,
      isHOC: true,
      isStyledHOC: false
    };
  }
  function extractable(Component2, extended) {
    return Component2.staticConfig = extendStyledConfig(extended), Component2.styleable = styleable, Component2;
  }
  function styleable(Component2, options) {
    let out = IS_REACT_19 && typeof Component2 == "function" && Component2.length === 1 || Component2.render?.length === 2 ? Component2 : import_react17.default.forwardRef(Component2);
    const extendedConfig = extendStyledConfig(options?.staticConfig);
    return out = options?.disableTheme ? out : themeable(out, extendedConfig, true), (extendedConfig.memo || process.env.TAMAGUI_MEMOIZE_STYLEABLE) && (out = import_react17.default.memo(out)), out.staticConfig = extendedConfig, out.styleable = styleable, out;
  }
  return res.extractable = extractable, res.styleable = styleable, res;
}
function getWebEvents(events, webStyle = true) {
  return {
    onMouseEnter: events.onMouseEnter,
    onMouseLeave: events.onMouseLeave,
    [webStyle ? "onClick" : "onPress"]: events.onPress,
    onMouseDown: events.onPressIn,
    onMouseUp: events.onPressOut,
    onTouchStart: events.onPressIn,
    onTouchEnd: events.onPressOut,
    onFocus: events.onFocus,
    onBlur: events.onBlur
  };
}
function Unspaced(props) {
  return props.children;
}
Unspaced.isUnspaced = true;
var getSpacerSize = (size, {
  tokens
}) => {
  size = size === false ? 0 : size === true ? "$true" : size;
  const sizePx = tokens.space[size] ?? size;
  return {
    width: sizePx,
    height: sizePx,
    minWidth: sizePx,
    minHeight: sizePx
  };
};
var Spacer = createComponent({
  acceptsClassName: true,
  memo: true,
  componentName: "Spacer",
  validStyles,
  defaultProps: {
    ...stackDefaultStyles,
    // avoid nesting issues
    tag: "span",
    size: true,
    pointerEvents: "none"
  },
  variants: {
    size: {
      "...": getSpacerSize
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  const {
    isZStack,
    children,
    space,
    direction,
    spaceFlex,
    separator,
    ensureKeys
  } = props, hasSpace = !!(space || spaceFlex), hasSeparator = separator != null, areChildrenArray = Array.isArray(children);
  if (!ensureKeys && !(hasSpace || hasSeparator || isZStack)) return children;
  const childrenList = areChildrenArray ? children : import_react17.default.Children.toArray(children);
  if (childrenList.length <= 1 && !isZStack && !childrenList[0]?.type?.shouldForwardSpace) return children;
  const final = [];
  for (let [index, child] of childrenList.entries()) {
    const isEmpty = child == null || Array.isArray(child) && child.length === 0;
    if (!isEmpty && import_react17.default.isValidElement(child) && child.type?.shouldForwardSpace && (child = import_react17.default.cloneElement(child, {
      // @ts-expect-error we explicitly know with shouldForwardSpace
      space,
      spaceFlex,
      separator,
      key: child.key
    })), isEmpty || !child || child.key && !isZStack ? final.push(child) : final.push((0, import_jsx_runtime8.jsx)(import_react17.default.Fragment, {
      children: isZStack ? (0, import_jsx_runtime8.jsx)(AbsoluteFill, {
        children: child
      }) : child
    }, `${index}0t`)), isUnspaced(child) && index === 0 || isZStack) continue;
    const next = childrenList[index + 1];
    next && !isEmpty && !isUnspaced(next) && (separator ? (hasSpace && final.push(createSpacer({
      key: `_${index}_00t`,
      direction,
      space,
      spaceFlex
    })), final.push((0, import_jsx_runtime8.jsx)(import_react17.default.Fragment, {
      children: separator
    }, `${index}03t`)), hasSpace && final.push(createSpacer({
      key: `_${index}01t`,
      direction,
      space,
      spaceFlex
    }))) : final.push(createSpacer({
      key: `_${index}02t`,
      direction,
      space,
      spaceFlex
    })));
  }
  return props.debug && log("  Spaced children", final, props), final;
}
function createSpacer({
  key,
  direction,
  space,
  spaceFlex
}) {
  return (0, import_jsx_runtime8.jsx)(Spacer, {
    size: space,
    direction,
    ...typeof spaceFlex < "u" && {
      flex: spaceFlex === true ? 1 : spaceFlex === false ? 0 : spaceFlex
    }
  }, key);
}
function isUnspaced(child) {
  const t = child?.type;
  return t?.isVisuallyHidden || t?.isUnspaced;
}
var AbsoluteFill = createComponent({
  defaultProps: {
    ...stackDefaultStyles,
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  }
});
var fromPx = (val) => typeof val == "number" ? val : typeof val == "string" ? +val.replace("px", "") : 0;

// ../../node_modules/@tamagui/web/dist/esm/helpers/isTamaguiComponent.mjs
function isTamaguiComponent(comp, name) {
  const config = comp?.staticConfig;
  return !!(config && (!name || name === config.componentName));
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/isTamaguiElement.mjs
var import_react18 = __toESM(require_react(), 1);
var isTamaguiElement = (child, name) => import_react18.default.isValidElement(child) && isTamaguiComponent(child.type, name);

// ../../node_modules/@tamagui/web/dist/esm/createFont.mjs
var fontWeights = ["100", "200", "300", "400", "500", "600", "700", "800", "900"];
var processSection = (section, keys, defaultValue2) => {
  if (typeof section == "string") return section;
  const sectionKeys = Object.keys(section);
  let fillValue = section[sectionKeys[0]];
  return Object.fromEntries([.../* @__PURE__ */ new Set([...keys, ...sectionKeys])].map((key) => {
    const value = section[key] ?? defaultValue2 ?? fillValue;
    return fillValue = value, defaultValue2 = value, [key, value];
  }));
};
var createFont = (font) => {
  const sizeKeys = Object.keys(font.size || {}), processedFont = Object.fromEntries(Object.entries(font).map(([key, section]) => [key, processSection(section, key === "face" ? fontWeights : sizeKeys, key === "face" ? {
    normal: font.family
  } : void 0)]));
  return Object.freeze(processedFont);
};

// ../../node_modules/@tamagui/web/dist/esm/createShorthands.mjs
function createShorthands(shorthands) {
  return Object.freeze(shorthands);
}

// ../../node_modules/@tamagui/web/dist/esm/createVariables.mjs
var cache6 = /* @__PURE__ */ new WeakMap();
var createVariables = (tokens, parentPath = "", isFont = false) => {
  if (cache6.has(tokens)) return tokens;
  const res = {};
  let i = 0;
  for (let keyIn in tokens) {
    i++;
    const val = tokens[keyIn], isPrefixed = keyIn[0] === "$", keyWithPrefix = isPrefixed ? keyIn : `$${keyIn}`, key = isPrefixed ? keyWithPrefix.slice(1) : keyIn;
    if (isVariable(val)) {
      res[key] = val;
      continue;
    }
    const niceKey = simpleHash(key, 1e3), name = parentPath && parentPath !== "t-color" ? `${parentPath}-${niceKey}` : `c-${niceKey}`;
    if (val && typeof val == "object" && "needsPx" in val && "val" in val) {
      const finalValue2 = createVariable({
        val: val.val,
        name,
        key: keyWithPrefix
      });
      isWeb && (finalValue2.needsPx = val.needsPx), res[key] = finalValue2;
      continue;
    }
    if (val && typeof val == "object") {
      res[key] = createVariables(
        tokens[key],
        name,
        false
        /* note: don't pass isFont down, we want to avoid it past the first level */
      );
      continue;
    }
    const finalValue = isVariable(val) ? val : createVariable({
      val,
      name,
      key: keyWithPrefix
    });
    res[key] = finalValue;
  }
  return cache6.set(res, true), res;
};

// ../../node_modules/@tamagui/web/dist/esm/helpers/registerCSSVariable.mjs
var registerCSSVariable = (v) => {
  tokensValueToVariable.set(getVariableValue(v), v);
};
var variableToCSS = (v, unitless = false) => `--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${createCSSVariable(v.name, false)}:${!unitless && typeof v.val == "number" ? `${v.val}px` : v.val}`;
var tokensValueToVariable = /* @__PURE__ */ new Map();

// ../../node_modules/@tamagui/web/dist/esm/insertFont.mjs
function insertFont(name, fontIn) {
  const font = createFont(fontIn), tokened = createVariables(font, name), parsed = parseFont(tokened);
  if (typeof document < "u") {
    const fontVars = registerFontVariables(parsed), styleElement = document.querySelector(`style[${FONT_DATA_ATTRIBUTE_NAME}="${name}"]`) || document.createElement("style");
    styleElement.innerText = `:root .font_${name} {${fontVars.join(";")}}`, styleElement.setAttribute(FONT_DATA_ATTRIBUTE_NAME, name), document.head.appendChild(styleElement);
  }
  return setConfigFont(name, tokened, parsed), parsed;
}
function parseFont(definition) {
  const parsed = {};
  for (const attrKey in definition) {
    const attr = definition[attrKey];
    if (attrKey === "family" || attrKey === "face") parsed[attrKey] = attr;
    else {
      parsed[attrKey] = {};
      for (const key in attr) {
        let val = attr[key];
        val.val?.[0] === "$" && (val = val.val), parsed[attrKey][`$${key}`] = val;
      }
    }
  }
  return parsed;
}
function registerFontVariables(parsedFont) {
  const response = [];
  for (const fkey in parsedFont) if (fkey !== "face") {
    if (fkey === "family") {
      const val = parsedFont[fkey];
      registerCSSVariable(val), response.push(variableToCSS(val));
    } else for (const fskey in parsedFont[fkey]) if (typeof parsedFont[fkey][fskey] != "string") {
      const val = parsedFont[fkey][fskey];
      registerCSSVariable(val), response.push(variableToCSS(val));
    }
  }
  return response;
}

// ../../node_modules/@tamagui/web/dist/esm/createTheme.mjs
var createTheme = (theme) => theme;

// ../../node_modules/@tamagui/web/dist/esm/createTokens.mjs
function createTokens(tokens) {
  return createVariables(tokens, process.env.TAMAGUI_TOKEN_PREFIX ?? "t");
}

// ../../node_modules/@tamagui/web/dist/esm/setupReactNative.mjs
var ReactNativeStaticConfigs = /* @__PURE__ */ new WeakMap();
function getReactNativeConfig(Component) {
  if (Component) return Component.getSize && Component.prefetch ? RNConfigs.Image : Component.displayName === "Text" && Component.render ? RNConfigs.Text : Component.render && (Component.displayName === "ScrollView" || Component.displayName === "View") ? RNConfigs.default : Component.State?.blurTextInput ? RNConfigs.TextInput : ReactNativeStaticConfigs.get(Component);
}
var RNConfigs = {
  Image: {
    isReactNative: true,
    inlineProps: /* @__PURE__ */ new Set(["src", "width", "height"])
  },
  Text: {
    isReactNative: true,
    isText: true
  },
  TextInput: {
    isReactNative: true,
    isInput: true,
    isText: true
  },
  default: {
    isReactNative: true
  }
};
function setupReactNative(rnExports) {
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/mergeVariants.mjs
var mergeVariants = (parentVariants, ourVariants, level = 0) => {
  const variants = {};
  for (const key in ourVariants) {
    const parentVariant = parentVariants?.[key], ourVariant = ourVariants[key];
    !parentVariant || typeof ourVariant == "function" ? variants[key] = ourVariant : parentVariant && !ourVariant ? variants[key] = parentVariant[key] : level === 0 ? variants[key] = mergeVariants(parentVariant, ourVariant, level + 1) : variants[key] = {
      ...parentVariant,
      ...ourVariant
    };
  }
  return {
    ...parentVariants,
    ...variants
  };
};

// ../../node_modules/@tamagui/web/dist/esm/styled.mjs
function styled(ComponentIn, options, config) {
  if (!ComponentIn) throw new Error("No component given to styled()");
  const parentStaticConfig = ComponentIn.staticConfig, isPlainStyledComponent = !!parentStaticConfig && !(parentStaticConfig.isReactNative || parentStaticConfig.isHOC);
  let Component = parentStaticConfig?.isHOC && !parentStaticConfig?.isStyledHOC || isPlainStyledComponent ? ComponentIn : parentStaticConfig?.Component || ComponentIn;
  const reactNativeConfig = parentStaticConfig ? void 0 : getReactNativeConfig(Component), isReactNative = !!(reactNativeConfig || config?.isReactNative || parentStaticConfig?.isReactNative), staticConfigProps = (() => {
    let {
      variants,
      name,
      defaultVariants,
      acceptsClassName: acceptsClassNameProp,
      context,
      ...defaultProps
    } = options || {}, parentDefaultVariants, parentDefaultProps;
    if (parentStaticConfig && !(parentStaticConfig.isHOC && !parentStaticConfig.isStyledHOC)) {
      const pdp = parentStaticConfig.defaultProps;
      for (const key in pdp) {
        const val = pdp[key];
        parentStaticConfig.defaultVariants && key in parentStaticConfig.defaultVariants && (!defaultVariants || !(key in defaultVariants)) && (parentDefaultVariants ||= {}, parentDefaultVariants[key] = val), !(key in defaultProps) && (!defaultVariants || !(key in defaultVariants)) && (parentDefaultProps ||= {}, parentDefaultProps[key] = pdp[key]);
      }
      parentStaticConfig.variants && (variants = mergeVariants(parentStaticConfig.variants, variants));
    }
    (parentDefaultProps || defaultVariants || parentDefaultVariants) && (defaultProps = {
      ...parentDefaultProps,
      ...parentDefaultVariants,
      ...defaultProps,
      ...defaultVariants
    }), parentStaticConfig?.isHOC && name && (defaultProps.componentName = name);
    const isText = !!(config?.isText || parentStaticConfig?.isText), acceptsClassName = config?.acceptsClassName ?? acceptsClassNameProp ?? (isPlainStyledComponent || isReactNative || parentStaticConfig?.isHOC && parentStaticConfig?.acceptsClassName), conf4 = {
      ...parentStaticConfig,
      ...config,
      ...!isPlainStyledComponent && {
        Component
      },
      // @ts-expect-error
      variants,
      defaultProps,
      defaultVariants,
      componentName: name || parentStaticConfig?.componentName,
      isReactNative,
      isText,
      acceptsClassName,
      context,
      ...reactNativeConfig,
      isStyledHOC: !!parentStaticConfig?.isHOC,
      parentStaticConfig
    };
    return (defaultProps.children || !acceptsClassName || context) && (conf4.neverFlatten = true), conf4;
  })(), component = createComponent(staticConfigProps || {});
  for (const key in ComponentIn) key !== "propTypes" && (key in component || (component[key] = ComponentIn[key]));
  return component;
}

// ../../node_modules/@tamagui/web/dist/esm/hooks/useIsTouchDevice.mjs
var useIsTouchDevice = () => isWeb ? useDidFinishSSR() ? isTouchable : false : true;

// ../../node_modules/@tamagui/web/dist/esm/hooks/useProps.mjs
var import_react19 = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/web/dist/esm/views/Stack.mjs
var Stack = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
Stack.displayName = "Stack";

// ../../node_modules/@tamagui/web/dist/esm/hooks/useProps.mjs
function useProps(props, opts) {
  const [propsOut, styleOut] = usePropsAndStyle(props, {
    ...opts,
    noExpand: true,
    noNormalize: true,
    resolveValues: "none"
  });
  return {
    ...propsOut,
    ...styleOut
  };
}
function useStyle(props, opts) {
  return usePropsAndStyle(props, opts)[1] || {};
}
function usePropsAndStyle(props, opts) {
  const staticConfig = opts?.forComponent?.staticConfig ?? Stack.staticConfig, [theme, themeState] = useThemeWithState({
    componentName: staticConfig.componentName,
    name: "theme" in props ? props.theme : void 0,
    inverse: "themeInverse" in props ? props.themeInverse : void 0,
    needsUpdate() {
      return true;
    }
  }), componentContext = import_react19.default.useContext(ComponentContext), groupContext = import_react19.default.useContext(GroupContext), {
    state,
    disabled,
    setStateShallow
  } = useComponentState(props, componentContext.animationDriver, staticConfig, getConfig()), mediaStateNow = opts?.noMedia ? (
    // not safe to use mediaState but really marginal to hit this
    mediaState
  ) : useMedia(), splitStyles = useSplitStyles(props, staticConfig, theme, themeState?.name || "", state, {
    isAnimated: false,
    mediaState: mediaStateNow,
    noSkip: true,
    noMergeStyle: true,
    noClass: true,
    resolveValues: "auto",
    ...opts
  }, null, componentContext, groupContext), {
    mediaGroups,
    pseudoGroups
  } = splitStyles || {};
  return useIsomorphicLayoutEffect(() => {
    if (!disabled) {
      if (state.unmounted) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      if (groupContext) return subscribeToContextGroup({
        groupContext,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }
  }, [disabled, groupContext, pseudoGroups ? Object.keys([...pseudoGroups]).join("") : 0, mediaGroups ? Object.keys([...mediaGroups]).join("") : 0]), [splitStyles?.viewProps || {}, splitStyles?.style || {}, theme, mediaState];
}

// ../../node_modules/@tamagui/web/dist/esm/hooks/useThemeName.mjs
var forceUpdateState = {
  forceClassName: true,
  deopt: true,
  needsUpdate: () => true
};
var forceKeys = {
  current: /* @__PURE__ */ new Set([""])
};
function useThemeName() {
  return useThemeState(forceUpdateState, false, forceKeys)?.name || "";
}

// ../../node_modules/@tamagui/web/dist/esm/views/Configuration.mjs
var import_react20 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var Configuration = (props) => {
  const current = import_react20.default.useContext(ComponentContext);
  return (0, import_jsx_runtime9.jsx)(ClientOnly, {
    enabled: props.disableSSR ?? current.disableSSR,
    children: (0, import_jsx_runtime9.jsx)(ComponentContext.Provider, {
      ...current,
      ...props
    })
  });
};

// ../../node_modules/@tamagui/web/dist/esm/views/FontLanguage.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var FontLanguage = ({
  children,
  ...props
}) => (0, import_jsx_runtime10.jsx)("div", {
  style: {
    display: "contents"
  },
  className: Object.entries(props).map(([name, language]) => `t_lang-${name}-${language}`).join(" "),
  children
});
FontLanguage.displayName = "FontLanguage";

// ../../node_modules/@tamagui/use-event/dist/esm/useGet.mjs
var React13 = __toESM(require_react(), 1);
function useGet(currentValue, initialValue, forwardToFunction) {
  const curRef = React13.useRef(initialValue ?? currentValue);
  return useIsomorphicLayoutEffect(() => {
    curRef.current = currentValue;
  }), React13.useCallback(forwardToFunction ? (...args) => curRef.current?.apply(null, args) : () => curRef.current, []);
}

// ../../node_modules/@tamagui/use-event/dist/esm/useEvent.mjs
function useEvent(callback) {
  return useGet(callback, defaultValue, true);
}
var defaultValue = () => {
  throw new Error("Cannot call an event handler while rendering.");
};

// ../../node_modules/@tamagui/web/dist/esm/_withStableStyle.mjs
var import_react21 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@tamagui/web/dist/esm/helpers/getExpandedShorthands.mjs
function getExpandedShorthand(propKey, props) {
  const shorthands = getConfig().inverseShorthands;
  return props[propKey] ?? props[shorthands[propKey]];
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/getShorthandValue.mjs
var inverseShorthands = null;
var getShorthandValue = (props, key) => (inverseShorthands ||= getConfig().inverseShorthands, props[key] ?? (inverseShorthands ? props[inverseShorthands[key]] : void 0));

// ../../node_modules/@tamagui/web/dist/esm/helpers/getThemeCSSRules.mjs
var darkLight = ["dark", "light"];
var lightDark = ["light", "dark"];
function getThemeCSSRules(props) {
  const cssRuleSets = [];
  if (!process.env.TAMAGUI_DOES_SSR_CSS || process.env.TAMAGUI_DOES_SSR_CSS === "mutates-themes" || process.env.TAMAGUI_DOES_SSR_CSS === "false") {
    const {
      config,
      themeName,
      theme,
      names
    } = props, hasDarkLight = props.hasDarkLight ?? (config.themes && ("light" in config.themes || "dark" in config.themes)), CNP = `.${THEME_CLASSNAME_PREFIX}`;
    let vars = "";
    for (const themeKey in theme) {
      const variable = theme[themeKey];
      let value = null;
      tokensValueToVariable.has(variable.val) ? value = tokensValueToVariable.get(variable.val).variable : value = variable.val, vars += `--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${simpleHash(themeKey, 40)}:${value};`;
    }
    const isDarkBase = themeName === "dark", isLightBase = themeName === "light", baseSelectors = names.map((name) => `${CNP}${name}`), selectorsSet = new Set(isDarkBase || isLightBase ? baseSelectors : []);
    if (hasDarkLight) {
      const maxDepth = getSetting("maxDarkLightNesting") ?? 3;
      for (const subName of names) {
        const isDark = isDarkBase || subName.startsWith("dark_"), isLight = !isDark && (isLightBase || subName.startsWith("light_"));
        if (!(isDark || isLight)) {
          selectorsSet.add(`${CNP}${subName}`);
          continue;
        }
        const childSelector = `${CNP}${subName.replace(/^(dark|light)_/, "")}`, order = isDark ? darkLight : lightDark, [stronger, weaker] = order, numSelectors = Math.round(maxDepth * 1.5);
        for (let depth = 0; depth < numSelectors; depth++) {
          const isOdd = depth % 2 === 1;
          if (isOdd && depth < 3) continue;
          const parents = new Array(depth + 1).fill(0).map((_, idx) => `${CNP}${idx % 2 === 0 ? stronger : weaker}`);
          let parentSelectors = parents.length > 1 ? parents.slice(1) : parents;
          if (isOdd) {
            const [_first, second, ...rest] = parentSelectors;
            parentSelectors = [second, ...rest, second];
          }
          const lastParentSelector = parentSelectors[parentSelectors.length - 1], nextChildSelector = childSelector === lastParentSelector ? "" : childSelector, parentSelectorString = parentSelectors.join(" ");
          selectorsSet.add(`${parentSelectorString} ${nextChildSelector}`);
        }
      }
    }
    const selectors2 = [...selectorsSet].sort(sortString), css = `${selectors2.map((x) => `:root${isBaseTheme(x) && getSetting("themeClassNameOnRoot") ? "" : " "}${x}`).join(", ") + ", .tm_xxt"} {${vars}}`;
    if (cssRuleSets.push(css), getSetting("shouldAddPrefersColorThemes")) {
      const bgString = theme.background ? `background:${variableToString(theme.background)};` : "", fgString = theme.color ? `color:${variableToString(theme.color)}` : "", bodyRules = `body{${bgString}${fgString}}`, isDark = themeName.startsWith("dark"), baseName = isDark ? "dark" : "light", themeRules = `${selectors2.map((x) => {
        if (x == darkSelector || x === lightSelector) return ":root";
        if (!(isDark && x.startsWith(lightSelector) || !isDark && x.startsWith(darkSelector))) return x.replace(/^\.t_(dark|light) /, "").trim();
      }).filter(Boolean).join(", ")} {${vars}}`, prefersMediaSelectors = `@media(prefers-color-scheme:${baseName}){
    ${bodyRules}
    ${themeRules}
  }`;
      cssRuleSets.push(prefersMediaSelectors);
    }
    const selectionStyles = getSetting("selectionStyles");
    if (selectionStyles) {
      const rules = selectionStyles(theme);
      if (rules) {
        const selectionSelectors = baseSelectors.map((s) => `${s} ::selection`).join(", "), styles = Object.entries(rules).flatMap(([k, v]) => v ? `${k === "backgroundColor" ? "background" : k}:${variableToString(v)}` : []).join(";");
        if (styles) {
          const css2 = `${selectionSelectors}{${styles}}`;
          cssRuleSets.push(css2);
        }
      }
    }
  }
  return cssRuleSets;
}
var darkSelector = ".t_dark";
var lightSelector = ".t_light";
var isBaseTheme = (x) => x === darkSelector || x === lightSelector || x.startsWith(".t_dark ") || x.startsWith(".t_light ");

// ../../node_modules/@tamagui/web/dist/esm/helpers/proxyThemeToParents.mjs
var themesRaw = {};
function proxyThemesToParents(dedupedThemes) {
  for (const {
    names,
    theme
  } of dedupedThemes) for (const name of names) themesRaw[name] = theme;
  const themes2 = {};
  for (const {
    names,
    theme
  } of dedupedThemes) for (const themeName of names) {
    const proxiedTheme = proxyThemeToParents(themeName, theme);
    themes2[themeName] = proxiedTheme;
  }
  return themes2;
}
function proxyThemeToParents(themeName, theme) {
  const out = {}, cur = [], parents = themeName.split("_").slice(0, -1).map((part) => (cur.push(part), cur.join("_")));
  for (const parent of parents) Object.assign(out, themesRaw[parent]);
  return Object.assign(out, theme), out;
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/themes.mjs
function ensureThemeVariable(theme, key) {
  const val = theme[key];
  isVariable(val) ? val.name !== key && (theme[key] = createVariable({
    key: val.name,
    name: key,
    val: val.val
  })) : theme[key] = createVariable({
    key,
    name: key,
    val
  });
}

// ../../node_modules/@tamagui/web/dist/esm/helpers/defaultAnimationDriver.mjs
var noAnimationDriver = (method) => {
  console.warn(`No animation driver configured. To use ${method}, you must pass \`animations\` to createTamagui. See: https://tamagui.dev/docs/core/animations`);
};
var createEmptyAnimationDriver = () => ({
  isReactNative: false,
  supportsCSS: true,
  classNameAnimation: true,
  isStub: true,
  animations: {},
  useAnimations: () => noAnimationDriver("animations"),
  usePresence: () => noAnimationDriver("usePresence"),
  ResetPresence: () => noAnimationDriver("ResetPresence"),
  useAnimatedNumber: () => noAnimationDriver("useAnimatedNumber"),
  useAnimatedNumberStyle: () => noAnimationDriver("useAnimatedNumberStyle"),
  useAnimatedNumberReaction: () => noAnimationDriver("useAnimatedNumberReaction")
});
var defaultAnimationDriver = createEmptyAnimationDriver();

// ../../node_modules/@tamagui/web/dist/esm/Tamagui.mjs
var Tamagui = (() => {
  if (true) {
    class TamaguiManager {
      Helpers = esm_exports;
      get mediaState() {
        return {
          ...mediaState
        };
      }
      get config() {
        return getConfig();
      }
      get insertedRules() {
        return getAllRules();
      }
      get allSelectors() {
        return getAllSelectors();
      }
      get identifierToValue() {
        return identifierToValue;
      }
    }
    return new TamaguiManager();
  }
})();
var identifierToValue = /* @__PURE__ */ new Map();

// ../../node_modules/@tamagui/web/dist/esm/createTamagui.mjs
function shouldTokenCategoryHaveUnits(category) {
  return (/* @__PURE__ */ new Set(["size", "space", "radius"])).has(category);
}
function createTamagui(configIn) {
  const existingConfig = getConfigMaybe();
  existingConfig && (configIn = {
    ...existingConfig,
    ...configIn
  });
  const tokensParsed = {}, tokens = createVariables(configIn.tokens || {});
  if (configIn.tokens) {
    const tokensMerged2 = {};
    for (const cat in tokens) {
      tokensParsed[cat] = {}, tokensMerged2[cat] = {};
      const tokenCat = tokens[cat];
      for (const key in tokenCat) {
        const val = tokenCat[key], prefixedKey = `$${key}`;
        tokensParsed[cat][prefixedKey] = val, tokensMerged2[cat][prefixedKey] = val, tokensMerged2[cat][key] = val;
      }
    }
    setTokens(tokensMerged2);
  }
  let foundThemes;
  if (configIn.themes) {
    const noThemes = Object.keys(configIn.themes).length === 0;
    noThemes && (foundThemes = scanAllSheets(noThemes, tokensParsed));
  }
  let fontSizeTokens = null, fontsParsed;
  if (configIn.fonts) {
    const fontTokens = Object.fromEntries(Object.entries(configIn.fonts).map(([k, v]) => [k, createVariables(v, "f", true)]));
    fontsParsed = (() => {
      const res = {};
      for (const familyName in fontTokens) {
        const font = fontTokens[familyName], fontParsed = parseFont(font);
        res[`$${familyName}`] = fontParsed, !fontSizeTokens && fontParsed.size && (fontSizeTokens = new Set(Object.keys(fontParsed.size)));
      }
      return res;
    })();
  }
  const specificTokens = {}, themeConfig = (() => {
    const cssRuleSets = [], declarations = [], fontDeclarations = {}, sortedTokenKeys = Object.keys(tokens).sort();
    for (const key of sortedTokenKeys) {
      const sortedSubKeys = Object.keys(tokens[key]).sort();
      for (const skey of sortedSubKeys) {
        const variable = tokens[key][skey];
        if (specificTokens[`$${key}.${skey}`] = variable, typeof variable > "u") throw new Error(`No value for tokens.${key}.${skey}:
${JSON.stringify(variable, null, 2)}`);
        if (isWeb) {
          registerCSSVariable(variable);
          const variableNeedsPx = variable.needsPx === true, categoryNeedsPx = shouldTokenCategoryHaveUnits(key), shouldBeUnitless = !(variableNeedsPx || categoryNeedsPx);
          declarations.push(variableToCSS(variable, shouldBeUnitless));
        }
      }
    }
    {
      let declarationsToRuleSet = function(decs, selector = "") {
        return `:root${selector} {${sep}${[...decs].join(`;${sep}`)}${sep}}`;
      };
      const sortedFontKeys = fontsParsed ? Object.keys(fontsParsed).sort() : [];
      for (const key of sortedFontKeys) {
        const fontParsed = fontsParsed[key], [name, language] = key.includes("_") ? key.split("_") : [key], fontVars = registerFontVariables(fontParsed);
        fontDeclarations[key] = {
          name: name.slice(1),
          declarations: fontVars,
          language
        };
      }
      const sep = configIn.cssStyleSeparator || "";
      if (cssRuleSets.push(declarationsToRuleSet(declarations)), fontDeclarations) {
        const sortedFontDeclarationKeys = Object.keys(fontDeclarations).sort();
        for (const key of sortedFontDeclarationKeys) {
          const {
            name,
            declarations: declarations2,
            language = "default"
          } = fontDeclarations[key], fontSelector = `.font_${name}`, langSelector = `:root .t_lang-${name}-${language} ${fontSelector}`, selectors2 = language === "default" ? ` ${fontSelector}, ${langSelector}` : langSelector, specificRuleSet = declarationsToRuleSet(declarations2, selectors2);
          cssRuleSets.push(specificRuleSet);
        }
      }
    }
    const themesIn = configIn.themes, dedupedThemes = foundThemes ?? getThemesDeduped(themesIn, tokens.color);
    return {
      themes: proxyThemesToParents(dedupedThemes),
      cssRuleSets,
      getThemeRulesSets() {
        let themeRuleSets = [];
        if (isWeb) for (const {
          names,
          theme
        } of dedupedThemes) {
          const nextRules = getThemeCSSRules({
            config: configIn,
            themeName: names[0],
            names,
            theme
          });
          themeRuleSets = [...themeRuleSets, ...nextRules];
        }
        return themeRuleSets;
      }
    };
  })(), userShorthands = configIn.shorthands || {}, shorthands = {
    ...builtinShorthands,
    ...userShorthands
  };
  let lastCSSInsertedRulesIndex = -1;
  const getCSS = (opts = {}) => {
    {
      const {
        separator = `
`,
        sinceLastCall,
        exclude
      } = opts;
      if (sinceLastCall && lastCSSInsertedRulesIndex >= 0) {
        const rules = getAllRules();
        return lastCSSInsertedRulesIndex = rules.length, rules.slice(lastCSSInsertedRulesIndex).join(separator);
      }
      lastCSSInsertedRulesIndex = 0;
      const runtimeStyles = getAllRules().join(separator);
      return exclude === "design-system" ? runtimeStyles : `${`._ovs-contain {overscroll-behavior:contain;}
  .is_Text .is_Text {display:inline-flex;}
  ._dsp_contents {display:contents;}
  ._no_backdrop::backdrop {display: none;}
  ${themeConfig.cssRuleSets.join(separator)}`}
  ${exclude ? "" : themeConfig.getThemeRulesSets().join(separator)}
  ${runtimeStyles}`;
    }
  }, getNewCSS = (opts) => getCSS({
    ...opts,
    sinceLastCall: true
  }), defaultFontSetting = configIn.settings?.defaultFont ?? configIn.defaultFont, defaultFont = (() => {
    let val = defaultFontSetting;
    return val?.[0] === "$" && (val = val.slice(1)), val;
  })(), defaultFontToken = defaultFont ? `$${defaultFont}` : "", unset = {
    ...configIn.unset
  };
  !unset.fontFamily && defaultFont && (unset.fontFamily = defaultFontToken);
  const config = {
    fonts: {},
    onlyAllowShorthands: false,
    fontLanguages: [],
    animations: defaultAnimationDriver,
    media: {},
    ...configIn,
    unset,
    settings: {
      // move deprecated settings here so we can reference them all using `getSetting`
      // TODO remove this on v2
      disableSSR: configIn.disableSSR,
      defaultFont: configIn.defaultFont,
      disableRootThemeClass: configIn.disableRootThemeClass,
      onlyAllowShorthands: configIn.onlyAllowShorthands,
      mediaQueryDefaultActive: configIn.mediaQueryDefaultActive,
      themeClassNameOnRoot: configIn.themeClassNameOnRoot,
      cssStyleSeparator: configIn.cssStyleSeparator,
      webContainerType: "inline-size",
      ...configIn.settings
    },
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    userShorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(([k, v]) => [v, k])) : {},
    themes: themeConfig.themes,
    fontsParsed: fontsParsed || {},
    themeConfig,
    tokensParsed,
    parsed: true,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens,
    defaultFontToken
    // const tokens = [...getToken(tokens.size[0])]
    // .spacer-sm + ._dsp_contents._dsp-sm-hidden { margin-left: -var(--${}) }
  };
  return setConfig(config), configureMedia(config), configListeners.size && (configListeners.forEach((cb) => cb(config)), configListeners.clear()), process.env.DEBUG?.startsWith("tamagui") && console.info("Tamagui config:", config), globalThis.Tamagui || (globalThis.Tamagui = Tamagui), config;
}
function getThemesDeduped(themes2, colorTokens) {
  const dedupedThemes = [], existing = /* @__PURE__ */ new Map(), sortedThemeNames = Object.keys(themes2).sort();
  for (const themeName of sortedThemeNames) {
    const darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "", rawTheme = themes2[themeName], key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
    if (existing.has(key)) {
      existing.get(key).names.push(themeName);
      continue;
    }
    const theme = {
      ...colorTokens,
      ...rawTheme
    };
    for (const key2 in theme) ensureThemeVariable(theme, key2);
    const deduped = {
      names: [themeName],
      theme
    };
    dedupedThemes.push(deduped), existing.set(key, deduped);
  }
  return dedupedThemes;
}
var builtinShorthands = {
  fd: "flexDirection",
  fb: "flexBasis",
  bblr: "borderBottomLeftRadius",
  bbrr: "borderBottomRightRadius",
  fwr: "flexWrap",
  col: "color",
  ff: "fontFamily",
  fst: "fontStyle",
  tr: "transform",
  tt: "textTransform",
  td: "textDecorationLine",
  va: "verticalAlign",
  ws: "whiteSpace",
  wb: "wordBreak",
  ww: "wordWrap",
  brc: "borderRightColor",
  brw: "borderRightWidth",
  bs: "borderStyle",
  btc: "borderTopColor",
  btlr: "borderTopLeftRadius",
  btrr: "borderTopRightRadius",
  btw: "borderTopWidth",
  bw: "borderWidth",
  o: "opacity",
  cur: "cursor",
  pe: "pointerEvents",
  ov: "overflow",
  pos: "position",
  dsp: "display",
  fw: "fontWeight",
  fs: "fontSize",
  ls: "letterSpacing",
  lh: "lineHeight",
  bxs: "boxSizing",
  bxsh: "boxShadow",
  ox: "overflowX",
  oy: "overflowY"
};

// ../../node_modules/@tamagui/web/dist/esm/views/TamaguiProvider.mjs
var import_react23 = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/web/dist/esm/views/ThemeProvider.mjs
var import_react22 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var ThemeProvider = (props) => {
  const disableRootThemeClass = props.disableRootThemeClass ?? getSetting("disableRootThemeClass"), themeClassNameOnRoot = props.themeClassNameOnRoot ?? getSetting("themeClassNameOnRoot");
  return isClient && useIsomorphicLayoutEffect(() => {
    if (disableRootThemeClass) return;
    const cn = `${THEME_CLASSNAME_PREFIX}${props.defaultTheme}`, target = themeClassNameOnRoot ? document.documentElement : document.body;
    return target.classList.add(cn), () => {
      target.classList.remove(cn);
    };
  }, [props.defaultTheme, disableRootThemeClass, themeClassNameOnRoot]), (0, import_jsx_runtime12.jsx)(Theme, {
    className: props.className,
    name: props.defaultTheme,
    forceClassName: !disableRootThemeClass && !themeClassNameOnRoot,
    _isRoot: import_react22.useId,
    children: props.children
  });
};

// ../../node_modules/@tamagui/web/dist/esm/views/TamaguiProvider.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function TamaguiProvider({
  children,
  disableInjectCSS,
  config,
  className,
  defaultTheme,
  disableRootThemeClass,
  reset,
  themeClassNameOnRoot
}) {
  IS_REACT_19 || isClient && useIsomorphicLayoutEffect(() => {
    if (config && !disableInjectCSS) {
      const style = document.createElement("style");
      return style.appendChild(document.createTextNode(config.getCSS())), document.head.appendChild(style), () => {
        document.head.removeChild(style);
      };
    }
  }, [config, disableInjectCSS]), useIsomorphicLayoutEffect(() => {
    stopAccumulatingRules(), updateMediaListeners();
  }, []);
  let contents = (0, import_jsx_runtime13.jsx)(UnmountedClassName, {
    children: (0, import_jsx_runtime13.jsx)(ComponentContext.Provider, {
      animationDriver: config?.animations,
      children: (0, import_jsx_runtime13.jsx)(ThemeProvider, {
        themeClassNameOnRoot: themeClassNameOnRoot ?? getSetting("themeClassNameOnRoot"),
        disableRootThemeClass: disableRootThemeClass ?? getSetting("disableRootThemeClass"),
        defaultTheme: defaultTheme ?? (config ? Object.keys(config.themes)[0] : ""),
        reset,
        className,
        children
      })
    })
  });
  return getSetting("disableSSR") && (contents = (0, import_jsx_runtime13.jsx)(ClientOnly, {
    enabled: true,
    children: contents
  })), (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, {
    children: [contents, IS_REACT_19 && config && !disableInjectCSS && (0, import_jsx_runtime13.jsx)("style", {
      precedence: "default",
      href: "tamagui-css",
      children: config.getCSS()
    }, "tamagui-css")]
  });
}
function UnmountedClassName(props) {
  const [mounted, setMounted] = import_react23.default.useState(false);
  return import_react23.default.useEffect(() => {
    setMounted(true);
  }, []), isWeb ? (0, import_jsx_runtime13.jsx)("span", {
    style: {
      display: "contents"
    },
    className: mounted ? "" : "t_unmounted",
    children: props.children
  }) : props.children;
}
TamaguiProvider.displayName = "TamaguiProvider";

// ../../node_modules/@tamagui/web/dist/esm/views/Text.mjs
var ellipseStyle = {
  maxWidth: "100%",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
};
var defaultWebStyle = {
  display: "inline",
  // display: inline breaks css transform styles
  boxSizing: "border-box",
  wordWrap: "break-word",
  whiteSpace: "pre-wrap",
  margin: 0
};
var ellipsisStyle = ellipseStyle;
var Text = createComponent({
  acceptsClassName: true,
  isText: true,
  defaultProps: {
    fontFamily: "unset",
    ...defaultWebStyle
  },
  inlineWhenUnflattened: /* @__PURE__ */ new Set(["fontFamily"]),
  variants: {
    numberOfLines: {
      1: ellipseStyle,
      ":number": (numberOfLines) => numberOfLines >= 1 ? {
        WebkitLineClamp: numberOfLines,
        WebkitBoxOrient: "vertical",
        display: "-webkit-box",
        overflow: "hidden"
      } : null
    },
    selectable: {
      true: {
        userSelect: "text",
        cursor: "text"
      },
      false: {
        userSelect: "none",
        cursor: "default"
      }
    },
    /**
     * @deprecated Use ellipsis instead
     */
    ellipse: {
      true: ellipsisStyle
    },
    ellipsis: {
      true: ellipsisStyle
    }
  },
  validStyles: {
    ...validStyles,
    ...stylePropsTextOnly
  }
});
Text.displayName = "Text";

// ../../node_modules/@tamagui/web/dist/esm/views/View.mjs
var View = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});

// ../../node_modules/@tamagui/use-presence/dist/esm/PresenceContext.mjs
var React16 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var PresenceContext = React16.createContext(null);
var ResetPresence = (props) => {
  const parent = React16.useContext(PresenceContext);
  return (0, import_jsx_runtime14.jsx)(PresenceContext.Provider, {
    value: props.disable ? parent : null,
    children: props.children
  });
};

// ../../node_modules/@tamagui/use-presence/dist/esm/usePresence.mjs
var React17 = __toESM(require_react(), 1);
function usePresence() {
  const context = React17.useContext(PresenceContext);
  if (!context) return [true, null, context];
  const {
    id,
    isPresent: isPresent2,
    onExitComplete,
    register
  } = context;
  return React17.useEffect(() => register(id), []), !isPresent2 && onExitComplete ? [false, () => onExitComplete?.(id), context] : [true, void 0, context];
}
function useIsPresent() {
  return isPresent(React17.useContext(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}

// ../../node_modules/@tamagui/react-native-media-driver/dist/esm/matchMedia.mjs
var matchMedia2 = globalThis.matchMedia;

// ../../node_modules/@tamagui/react-native-media-driver/dist/esm/createMedia.mjs
function createMedia(media) {
  return setupMatchMedia(matchMedia2), media;
}

// ../../node_modules/@tamagui/use-element-layout/dist/esm/index.mjs
var import_react24 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var LayoutHandlers = /* @__PURE__ */ new WeakMap();
var LayoutDisableKey = /* @__PURE__ */ new WeakMap();
var Nodes = /* @__PURE__ */ new Set();
var IntersectionState = /* @__PURE__ */ new WeakMap();
var DisableLayoutContextValues = {};
var DisableLayoutContextKey = (0, import_react24.createContext)("");
var ENABLE = isClient && typeof IntersectionObserver < "u";
var LayoutMeasurementController = ({
  disable,
  children
}) => {
  const id = (0, import_react24.useId)();
  return useIsomorphicLayoutEffect(() => {
    DisableLayoutContextValues[id] = disable;
  }, [disable, id]), (0, import_jsx_runtime15.jsx)(DisableLayoutContextKey.Provider, {
    value: id,
    children
  });
};
var globalIntersectionObserver = null;
var strategy = "async";
function setOnLayoutStrategy(state) {
  strategy = state;
}
var NodeRectCache = /* @__PURE__ */ new WeakMap();
var LastChangeTime = /* @__PURE__ */ new WeakMap();
var avoidUpdates = true;
var queuedUpdates = /* @__PURE__ */ new Map();
function enable() {
  avoidUpdates && (avoidUpdates = false, queuedUpdates && (queuedUpdates.forEach((cb) => cb()), queuedUpdates.clear()));
}
function startGlobalObservers() {
  !ENABLE || globalIntersectionObserver || (globalIntersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      const node2 = entry.target;
      IntersectionState.get(node2) !== entry.isIntersecting && IntersectionState.set(node2, entry.isIntersecting);
    });
  }, {
    threshold: 0
  }));
}
if (ENABLE) {
  const BoundingRects = /* @__PURE__ */ new WeakMap();
  async function updateLayoutIfChanged(node2) {
    const onLayout = LayoutHandlers.get(node2);
    if (typeof onLayout != "function") return;
    const parentNode = node2.parentElement;
    if (!parentNode) return;
    let nodeRect, parentRect;
    if (strategy === "async") {
      const [nr, pr] = await Promise.all([BoundingRects.get(node2), BoundingRects.get(parentNode)]);
      if (!nr || !pr) return;
      nodeRect = nr, parentRect = pr;
    } else nodeRect = node2.getBoundingClientRect(), parentRect = parentNode.getBoundingClientRect();
    if (!nodeRect || !parentRect) return;
    const cachedRect = NodeRectCache.get(node2), cachedParentRect = NodeRectCache.get(parentNode);
    if (!cachedRect || !cachedParentRect || // has changed one rect
    // @ts-expect-error DOMRectReadOnly can go into object
    !isEqualShallow(cachedRect, nodeRect) || // @ts-expect-error DOMRectReadOnly can go into object
    !isEqualShallow(cachedParentRect, parentRect)) {
      NodeRectCache.set(node2, nodeRect), NodeRectCache.set(parentNode, parentRect);
      const event = getElementLayoutEvent(nodeRect, parentRect);
      avoidUpdates ? queuedUpdates.set(node2, () => onLayout(event)) : onLayout(event);
    }
  }
  const userSkipVal = process.env.TAMAGUI_LAYOUT_FRAME_SKIP, RUN_EVERY_X_FRAMES = userSkipVal ? +userSkipVal : 14;
  async function layoutOnAnimationFrame() {
    if (strategy !== "off") {
      const visibleNodes = [];
      await new Promise((res) => {
        const io = new IntersectionObserver((entries) => {
          io.disconnect();
          for (const entry of entries) BoundingRects.set(entry.target, entry.boundingClientRect);
          res(true);
        }, {
          threshold: 0
        });
        let didObserve = false;
        for (const node2 of Nodes) {
          if (!(node2.parentElement instanceof HTMLElement)) continue;
          const disableKey = LayoutDisableKey.get(node2);
          disableKey && DisableLayoutContextValues[disableKey] === true || IntersectionState.get(node2) !== false && (didObserve = true, io.observe(node2), io.observe(node2.parentElement), visibleNodes.push(node2));
        }
        didObserve || res(false);
      }) && visibleNodes.forEach((node2) => {
        updateLayoutIfChanged(node2);
      });
    }
    setTimeout(layoutOnAnimationFrame, 16.6667 * RUN_EVERY_X_FRAMES);
  }
  layoutOnAnimationFrame();
}
var getElementLayoutEvent = (nodeRect, parentRect) => ({
  nativeEvent: {
    layout: getRelativeDimensions(nodeRect, parentRect),
    target: nodeRect
  },
  timeStamp: Date.now()
});
var getRelativeDimensions = (a, b) => {
  const {
    height,
    left,
    top,
    width
  } = a, x = left - b.left, y = top - b.top;
  return {
    x,
    y,
    width,
    height,
    pageX: a.left,
    pageY: a.top
  };
};
function useElementLayout(ref, onLayout) {
  const disableKey = (0, import_react24.useContext)(DisableLayoutContextKey), node2 = ensureWebElement(ref.current?.host);
  node2 && onLayout && (LayoutHandlers.set(node2, onLayout), LayoutDisableKey.set(node2, disableKey)), useIsomorphicLayoutEffect(() => {
    if (!onLayout) return;
    const node22 = ref.current?.host;
    if (!node22) return;
    Nodes.add(node22), startGlobalObservers(), globalIntersectionObserver && (globalIntersectionObserver.observe(node22), IntersectionState.set(node22, true));
    const parentNode = node22.parentNode;
    return parentNode && onLayout(getElementLayoutEvent(node22.getBoundingClientRect(), parentNode.getBoundingClientRect())), () => {
      Nodes.delete(node22), LayoutHandlers.delete(node22), NodeRectCache.delete(node22), LastChangeTime.delete(node22), IntersectionState.delete(node22), globalIntersectionObserver && globalIntersectionObserver.unobserve(node22);
    };
  }, [ref, !!onLayout]);
}
function ensureWebElement(x) {
  if (!(typeof HTMLElement > "u")) return x instanceof HTMLElement ? x : void 0;
}
var getBoundingClientRectAsync = (node2) => new Promise((res) => {
  if (!node2 || node2.nodeType !== 1) return res(false);
  const io = new IntersectionObserver((entries) => (io.disconnect(), res(entries[0].boundingClientRect)), {
    threshold: 0
  });
  io.observe(node2);
});
var measureNode = async (node2, relativeTo) => {
  const relativeNode = relativeTo || node2?.parentElement;
  if (relativeNode instanceof HTMLElement) {
    const [nodeDim, relativeNodeDim] = await Promise.all([getBoundingClientRectAsync(node2), getBoundingClientRectAsync(relativeNode)]);
    if (relativeNodeDim && nodeDim) return getRelativeDimensions(nodeDim, relativeNodeDim);
  }
  return null;
};
var measure = async (node2, callback) => {
  const out = await measureNode(node2, node2.parentNode instanceof HTMLElement ? node2.parentNode : null);
  return out && callback?.(out.x, out.y, out.width, out.height, out.pageX, out.pageY), out;
};
function createMeasure(node2) {
  return (callback) => measure(node2, callback);
}
var measureInWindow = async (node2, callback) => {
  const out = await measureNode(node2, null);
  return out && callback?.(out.pageX, out.pageY, out.width, out.height), out;
};
var createMeasureInWindow = (node2) => (callback) => measureInWindow(node2, callback);
var measureLayout = async (node2, relativeNode, callback) => {
  const out = await measureNode(node2, relativeNode);
  return out && callback?.(out.x, out.y, out.width, out.height, out.pageX, out.pageY), out;
};
function createMeasureLayout(node2) {
  return (relativeTo, callback) => measureLayout(node2, relativeTo, callback);
}

// ../../node_modules/@tamagui/react-native-use-responder-events/dist/esm/useResponderEvents.mjs
var React18 = __toESM(require_react(), 1);

// ../../node_modules/@tamagui/react-native-use-responder-events/dist/esm/utils.mjs
var keyName = "__reactResponderId";
var canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement);
var getBoundingClientRect = (node2) => {
  if (node2 && node2.nodeType === 1 && node2.getBoundingClientRect) return node2.getBoundingClientRect();
};
function getEventPath(domEvent) {
  if (domEvent.type === "selectionchange") {
    const target = window.getSelection()?.anchorNode;
    return composedPathFallback(target);
  }
  return domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
}
function composedPathFallback(target) {
  const path = [];
  for (; target != null && target !== document.body; ) path.push(target), target = target.parentNode;
  return path;
}
function getResponderId(node2) {
  return node2 != null ? node2[keyName] : null;
}
function setResponderId(node2, id) {
  node2 != null && (node2[keyName] = id);
}
function getResponderPaths(domEvent) {
  const idPath = [], nodePath = [], eventPath = getEventPath(domEvent);
  for (let i = 0; i < eventPath.length; i++) {
    const node2 = eventPath[i], id = getResponderId(node2);
    id != null && (idPath.push(id), nodePath.push(node2));
  }
  return {
    idPath,
    nodePath
  };
}
function getLowestCommonAncestor(pathA, pathB) {
  let pathALength = pathA.length, pathBLength = pathB.length;
  if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]
  ) return null;
  let itemA = pathA[0], indexA = 0, itemB = pathB[0], indexB = 0;
  pathALength - pathBLength > 0 && (indexA = pathALength - pathBLength, itemA = pathA[indexA], pathALength = pathBLength), pathBLength - pathALength > 0 && (indexB = pathBLength - pathALength, itemB = pathB[indexB], pathBLength = pathALength);
  let depth = pathALength;
  for (; depth--; ) {
    if (itemA === itemB) return itemA;
    itemA = pathA[indexA++], itemB = pathB[indexB++];
  }
  return null;
}
function hasTargetTouches(target, touches) {
  if (!touches || touches.length === 0) return false;
  for (let i = 0; i < touches.length; i++) {
    const node2 = touches[i].target;
    if (node2 != null && target.contains(node2)) return true;
  }
  return false;
}
function hasValidSelection(domEvent) {
  return domEvent.type === "selectionchange" ? isSelectionValid() : domEvent.type === "select";
}
function isPrimaryPointerDown(domEvent) {
  const {
    altKey,
    button,
    buttons,
    ctrlKey,
    type
  } = domEvent, isTouch = type === "touchstart" || type === "touchmove", isPrimaryMouseDown = type === "mousedown" && (button === 0 || buttons === 1), isPrimaryMouseMove = type === "mousemove" && buttons === 1, noModifiers = altKey === false && ctrlKey === false;
  return !!(isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers);
}
function isSelectionValid() {
  const selection = window.getSelection();
  if (!selection) return false;
  const string = selection.toString(), anchorNode = selection.anchorNode, focusNode = selection.focusNode, isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
  return string.length >= 1 && string !== `
` && !!isTextNode;
}

// ../../node_modules/@tamagui/react-native-use-responder-events/dist/esm/createResponderEvent.mjs
var emptyFunction = () => {
};
var emptyObject2 = {};
var emptyArray = [];
function normalizeIdentifier(identifier) {
  return identifier > 20 ? identifier % 20 : identifier;
}
function createResponderEvent(domEvent, responderTouchHistoryStore2) {
  let rect, propagationWasStopped = false, changedTouches, touches;
  const domEventChangedTouches = domEvent.changedTouches, domEventType = domEvent.type, metaKey = domEvent.metaKey === true, shiftKey = domEvent.shiftKey === true, force = domEventChangedTouches?.[0].force || 0, identifier = normalizeIdentifier(domEventChangedTouches?.[0].identifier || 0), clientX = domEventChangedTouches?.[0].clientX || domEvent.clientX, clientY = domEventChangedTouches?.[0].clientY || domEvent.clientY, pageX = domEventChangedTouches?.[0].pageX || domEvent.pageX, pageY = domEventChangedTouches?.[0].pageY || domEvent.pageY, preventDefault = typeof domEvent.preventDefault == "function" ? domEvent.preventDefault.bind(domEvent) : emptyFunction, timestamp = domEvent.timeStamp;
  function normalizeTouches(touches2) {
    return Array.prototype.slice.call(touches2).map((touch) => ({
      force: touch.force,
      identifier: normalizeIdentifier(touch.identifier),
      get locationX() {
        return locationX(touch.clientX);
      },
      get locationY() {
        return locationY(touch.clientY);
      },
      pageX: touch.pageX,
      pageY: touch.pageY,
      target: touch.target,
      timestamp
    }));
  }
  if (domEventChangedTouches != null) changedTouches = normalizeTouches(domEventChangedTouches), touches = normalizeTouches(domEvent.touches);
  else {
    const emulatedTouches = [{
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp
    }];
    changedTouches = emulatedTouches, touches = domEventType === "mouseup" || domEventType === "dragstart" ? emptyArray : emulatedTouches;
  }
  const responderEvent = {
    bubbles: true,
    cancelable: true,
    // `currentTarget` is set before dispatch
    currentTarget: null,
    defaultPrevented: domEvent.defaultPrevented,
    dispatchConfig: emptyObject2,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented() {
      return domEvent.defaultPrevented;
    },
    isPropagationStopped() {
      return propagationWasStopped;
    },
    isTrusted: domEvent.isTrusted,
    nativeEvent: {
      altKey: false,
      ctrlKey: false,
      metaKey,
      shiftKey,
      changedTouches,
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp,
      touches,
      type: domEventType
    },
    persist: emptyFunction,
    preventDefault,
    stopPropagation() {
      propagationWasStopped = true;
    },
    target: domEvent.target,
    timeStamp: timestamp,
    touchHistory: responderTouchHistoryStore2.touchHistory
  };
  function locationX(x) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return x - rect.left;
  }
  function locationY(y) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return y - rect.top;
  }
  return responderEvent;
}

// ../../node_modules/@tamagui/react-native-use-responder-events/dist/esm/types.mjs
var MOUSE_DOWN = "mousedown";
var MOUSE_MOVE = "mousemove";
var MOUSE_UP = "mouseup";
var MOUSE_CANCEL = "dragstart";
var TOUCH_START = "touchstart";
var TOUCH_MOVE = "touchmove";
var TOUCH_END = "touchend";
var TOUCH_CANCEL = "touchcancel";
var SCROLL = "scroll";
var SELECT = "select";
var SELECTION_CHANGE = "selectionchange";
function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}
function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}
function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}
function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}
function isScroll(eventType) {
  return eventType === SCROLL;
}
function isSelectionChange(eventType) {
  return eventType === SELECT || eventType === SELECTION_CHANGE;
}

// ../../node_modules/@tamagui/react-native-use-responder-events/dist/esm/ResponderTouchHistoryStore.mjs
var ResponderTouchHistoryStore = class {
  _touchHistory = {
    touchBank: [],
    //Array<TouchRecord>
    numberActiveTouches: 0,
    // If there is only one active touch, we remember its location. This prevents
    // us having to loop through all of the touches all the time in the most
    // common case.
    indexOfSingleActiveTouch: -1,
    mostRecentTimeStamp: 0
  };
  recordTouchTrack(topLevelType, nativeEvent) {
    const touchHistory = this._touchHistory;
    if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach((touch) => recordTouchMove(touch, touchHistory));
    else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach((touch) => recordTouchStart(touch, touchHistory)), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1 && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);
    else if (isEndish(topLevelType) && (nativeEvent.changedTouches.forEach((touch) => recordTouchEnd(touch, touchHistory)), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1)) {
      const {
        touchBank
      } = touchHistory;
      for (let i = 0; i < touchBank.length; i++) if (touchBank[i]?.touchActive) {
        touchHistory.indexOfSingleActiveTouch = i;
        break;
      }
      touchBank[touchHistory.indexOfSingleActiveTouch]?.touchActive || console.error("Cannot find single active touch.");
    }
  }
  get touchHistory() {
    return this._touchHistory;
  }
};
var MAX_TOUCH_BANK = 20;
function timestampForTouch(touch) {
  return touch.timeStamp || touch.timestamp;
}
function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}
function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch);
}
function getTouchIdentifier({
  identifier
}) {
  return identifier == null && console.error("Touch object is missing identifier."), identifier > MAX_TOUCH_BANK && console.error("Touch identifier %s is greater than maximum supported %s which causes performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK), identifier;
}
function recordTouchStart(touch, touchHistory) {
  const identifier = getTouchIdentifier(touch), touchRecord = touchHistory.touchBank[identifier];
  touchRecord ? resetTouchRecord(touchRecord, touch) : touchHistory.touchBank[identifier] = createTouchRecord(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}
function recordTouchMove(touch, touchHistory) {
  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch move without a touch start.
`, `Touch Move: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function recordTouchEnd(touch, touchHistory) {
  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch end without a touch start.
`, `Touch End: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}
function printTouchBank(touchHistory) {
  const {
    touchBank
  } = touchHistory;
  let printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
  return touchBank.length > MAX_TOUCH_BANK && (printed += ` (original size: ${touchBank.length})`), printed;
}

// ../../node_modules/@tamagui/react-native-use-responder-events/dist/esm/ResponderSystem.mjs
var emptyObject3 = {};
var startRegistration = ["onStartShouldSetResponderCapture", "onStartShouldSetResponder", {
  bubbles: true
}];
var moveRegistration = ["onMoveShouldSetResponderCapture", "onMoveShouldSetResponder", {
  bubbles: true
}];
var scrollRegistration = ["onScrollShouldSetResponderCapture", "onScrollShouldSetResponder", {
  bubbles: false
}];
var shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
};
var emptyResponder = {
  id: null,
  idPath: null,
  node: null
};
var responderListenersMap = /* @__PURE__ */ new Map();
var isEmulatingMouseEvents = false;
var trackedTouchCount = 0;
var currentResponder = {
  id: null,
  node: null,
  idPath: null
};
var responderTouchHistoryStore = new ResponderTouchHistoryStore();
function changeCurrentResponder(responder) {
  currentResponder = responder;
}
function getResponderConfig(id) {
  const config = responderListenersMap.get(id);
  return config ?? emptyObject3;
}
function eventListener(domEvent) {
  const eventType = domEvent.type, eventTarget = domEvent.target;
  if (eventType === "touchstart" && (isEmulatingMouseEvents = true), (eventType === "touchmove" || trackedTouchCount > 1) && (isEmulatingMouseEvents = false), // Ignore browser emulated mouse events
  eventType === "mousedown" && isEmulatingMouseEvents || eventType === "mousemove" && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
  eventType === "mousemove" && trackedTouchCount < 1) return;
  if (isEmulatingMouseEvents && eventType === "mouseup") {
    trackedTouchCount === 0 && (isEmulatingMouseEvents = false);
    return;
  }
  const isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent), isMoveEvent = isMoveish(eventType), isEndEvent = isEndish(eventType), isScrollEvent = isScroll(eventType), isSelectionChangeEvent = isSelectionChange(eventType), responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);
  (isStartEvent || isMoveEvent || isEndEvent) && (domEvent.touches ? trackedTouchCount = domEvent.touches.length : isStartEvent ? trackedTouchCount = 1 : isEndEvent && (trackedTouchCount = 0), responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent));
  let eventPaths = getResponderPaths(domEvent), wasNegotiated = false, wantsResponder;
  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
    const currentResponderIdPath = currentResponder.idPath, eventIdPath = eventPaths.idPath;
    if (currentResponderIdPath != null && eventIdPath != null) {
      const lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);
      if (lowestCommonAncestor != null) {
        const index = eventIdPath.indexOf(lowestCommonAncestor) + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
        eventPaths = {
          idPath: eventIdPath.slice(index),
          nodePath: eventPaths.nodePath.slice(index)
        };
      } else eventPaths = null;
    }
    eventPaths != null && (wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent), wantsResponder != null && (attemptTransfer(responderEvent, wantsResponder), wasNegotiated = true));
  }
  if (currentResponder.id != null && currentResponder.node != null) {
    const {
      id,
      node: node2
    } = currentResponder, {
      onResponderStart,
      onResponderMove,
      onResponderEnd,
      onResponderRelease,
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(id);
    if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node2, isStartEvent) onResponderStart != null && (responderEvent.dispatchConfig.registrationName = "onResponderStart", onResponderStart(responderEvent));
    else if (isMoveEvent) onResponderMove != null && (responderEvent.dispatchConfig.registrationName = "onResponderMove", onResponderMove(responderEvent));
    else {
      const isTerminateEvent = isCancelish(eventType) || // native context menu
      eventType === "contextmenu" || // window blur
      eventType === "blur" && eventTarget === window || // responder (or ancestors) blur
      eventType === "blur" && eventTarget.contains(node2) && domEvent.relatedTarget !== node2 || // native scroll without using a pointer
      isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
      isScrollEvent && eventTarget.contains(node2) && eventTarget !== node2 || // native select/selectionchange on node
      isSelectionChangeEvent && hasValidSelection(domEvent), isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node2, domEvent.touches);
      if (isEndEvent && onResponderEnd != null && (responderEvent.dispatchConfig.registrationName = "onResponderEnd", onResponderEnd(responderEvent)), isReleaseEvent && (onResponderRelease != null && (responderEvent.dispatchConfig.registrationName = "onResponderRelease", onResponderRelease(responderEvent)), changeCurrentResponder(emptyResponder)), isTerminateEvent) {
        let shouldTerminate = true;
        (eventType === "contextmenu" || eventType === "scroll" || eventType === "selectionchange") && (wasNegotiated ? shouldTerminate = false : onResponderTerminationRequest != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (shouldTerminate = false))), shouldTerminate && (onResponderTerminate != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), changeCurrentResponder(emptyResponder), isEmulatingMouseEvents = false, trackedTouchCount = 0);
      }
    }
  }
}
function findWantsResponder(eventPaths, domEvent, responderEvent) {
  const shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];
  if (shouldSetCallbacks != null) {
    const {
      idPath,
      nodePath
    } = eventPaths, shouldSetCallbackCaptureName = shouldSetCallbacks[0], shouldSetCallbackBubbleName = shouldSetCallbacks[1], {
      bubbles
    } = shouldSetCallbacks[2], check = (id, node2, callbackName) => {
      const shouldSetCallback = getResponderConfig(id)[callbackName];
      if (shouldSetCallback != null && (responderEvent.currentTarget = node2, shouldSetCallback(responderEvent) === true)) {
        const prunedIdPath = idPath.slice(idPath.indexOf(id));
        return {
          id,
          node: node2,
          idPath: prunedIdPath
        };
      }
    };
    for (let i = idPath.length - 1; i >= 0; i--) {
      const id = idPath[i], node2 = nodePath[i], result = check(id, node2, shouldSetCallbackCaptureName);
      if (result != null) return result;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    if (bubbles) for (let i = 0; i < idPath.length; i++) {
      const id = idPath[i], node2 = nodePath[i], result = check(id, node2, shouldSetCallbackBubbleName);
      if (result != null) return result;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    else {
      const id = idPath[0], node2 = nodePath[0];
      if (domEvent.target === node2) return check(id, node2, shouldSetCallbackBubbleName);
    }
  }
}
function attemptTransfer(responderEvent, wantsResponder) {
  const {
    id: currentId,
    node: currentNode
  } = currentResponder, {
    id,
    node: node2
  } = wantsResponder, {
    onResponderGrant,
    onResponderReject
  } = getResponderConfig(id);
  if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node2, currentId == null) onResponderGrant != null && (responderEvent.currentTarget = node2, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder);
  else {
    const {
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(currentId);
    let allowTransfer = true;
    onResponderTerminationRequest != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (allowTransfer = false)), allowTransfer ? (onResponderTerminate != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), onResponderGrant != null && (responderEvent.currentTarget = node2, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder)) : onResponderReject != null && (responderEvent.currentTarget = node2, responderEvent.dispatchConfig.registrationName = "onResponderReject", onResponderReject(responderEvent));
  }
}
var documentEventsCapturePhase = ["blur", "scroll"];
var documentEventsBubblePhase = [
  // mouse
  "mousedown",
  "mousemove",
  "mouseup",
  "dragstart",
  // touch
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  // other
  "contextmenu",
  "select",
  "selectionchange"
];
var isTamaguiResponderActive = /* @__PURE__ */ Symbol();
function attachListeners() {
  canUseDOM && !window[isTamaguiResponderActive] && (window.addEventListener("blur", eventListener), documentEventsBubblePhase.forEach((eventType) => {
    document.addEventListener(eventType, eventListener);
  }), documentEventsCapturePhase.forEach((eventType) => {
    document.addEventListener(eventType, eventListener, true);
  }), window[isTamaguiResponderActive] = true);
}
function addNode(id, node2, config) {
  setResponderId(node2, id), responderListenersMap.set(id, config);
}
function removeNode(id) {
  currentResponder.id === id && terminateResponder(), responderListenersMap.has(id) && responderListenersMap.delete(id);
}
function terminateResponder() {
  const {
    id,
    node: node2
  } = currentResponder;
  if (id != null && node2 != null) {
    const {
      onResponderTerminate
    } = getResponderConfig(id);
    if (onResponderTerminate != null) {
      const event = createResponderEvent({}, responderTouchHistoryStore);
      event.currentTarget = node2, onResponderTerminate(event);
    }
    changeCurrentResponder(emptyResponder);
  }
  isEmulatingMouseEvents = false, trackedTouchCount = 0;
}
function getResponderNode() {
  return currentResponder.node;
}

// ../../node_modules/@tamagui/react-native-use-responder-events/dist/esm/useResponderEvents.mjs
var emptyObject4 = {};
var Attached = /* @__PURE__ */ new WeakMap();
var Ids = /* @__PURE__ */ new WeakMap();
function useResponderEvents(hostRef, configIn = emptyObject4) {
  const config = getResponderConfigIfDefined(configIn), node2 = hostRef?.current?.host || hostRef?.current;
  React18.useEffect(() => {
    if (config === emptyObject4) return;
    attachListeners(), Ids.has(hostRef) || Ids.set(hostRef, `${Math.random()}`);
    const id = Ids.get(hostRef);
    return addNode(id, node2, config), Attached.set(hostRef, true), () => {
      removeNode(node2), Attached.set(hostRef, false);
    };
  }, [config, hostRef]), React18.useDebugValue({
    isResponder: node2 === getResponderNode()
  }), React18.useDebugValue(config);
}
function getResponderConfigIfDefined({
  onMoveShouldSetResponder,
  onMoveShouldSetResponderCapture,
  onResponderEnd,
  onResponderGrant,
  onResponderMove,
  onResponderReject,
  onResponderRelease,
  onResponderStart,
  onResponderTerminate,
  onResponderTerminationRequest,
  onScrollShouldSetResponder,
  onScrollShouldSetResponderCapture,
  onSelectionChangeShouldSetResponder,
  onSelectionChangeShouldSetResponderCapture,
  onStartShouldSetResponder,
  onStartShouldSetResponderCapture
}) {
  return onMoveShouldSetResponder || onMoveShouldSetResponderCapture || onResponderEnd || onResponderGrant || onResponderMove || onResponderReject || onResponderRelease || onResponderStart || onResponderTerminate || onResponderTerminationRequest || onScrollShouldSetResponder || onScrollShouldSetResponderCapture || onSelectionChangeShouldSetResponder || onSelectionChangeShouldSetResponderCapture || onStartShouldSetResponder || onStartShouldSetResponderCapture ? {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } : emptyObject4;
}

// ../../node_modules/@tamagui/core/dist/esm/getBaseViews.mjs
function getBaseViews() {
  return null;
}

// ../../node_modules/@tamagui/core/dist/esm/index.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var TamaguiProvider2 = (props) => (useIsomorphicLayoutEffect(() => {
  enable();
}, []), (0, import_jsx_runtime16.jsx)(TamaguiProvider, {
  ...props
}));
var createTamagui2 = (conf4) => createTamagui(conf4);
var baseViews = getBaseViews();
setupHooks({
  getBaseViews,
  setElementProps: (node2) => {
    node2 && !node2.measure && (node2.measure ||= createMeasure(node2), node2.measureInWindow ||= createMeasureInWindow(node2), node2.measureLayout ||= createMeasureLayout(node2));
  },
  usePropsTransform(elementType, propsIn, stateRef, willHydrate) {
    {
      const isDOM = typeof elementType == "string", {
        // remove event props handles by useResponderEvents
        onMoveShouldSetResponder,
        onMoveShouldSetResponderCapture,
        onResponderEnd,
        onResponderGrant,
        onResponderMove,
        onResponderReject,
        onResponderRelease,
        onResponderStart,
        onResponderTerminate,
        onResponderTerminationRequest,
        onScrollShouldSetResponder,
        onScrollShouldSetResponderCapture,
        onSelectionChangeShouldSetResponder,
        onSelectionChangeShouldSetResponderCapture,
        onStartShouldSetResponder,
        onStartShouldSetResponderCapture,
        // android
        collapsable,
        focusable,
        // deprecated,
        accessible,
        accessibilityDisabled,
        onLayout,
        hrefAttrs,
        ...plainDOMProps
      } = propsIn;
      if ((willHydrate || isDOM) && (useElementLayout(stateRef, isDOM ? onLayout : void 0), useResponderEvents(stateRef, isDOM ? propsIn : void 0)), isDOM) {
        if (plainDOMProps.href && hrefAttrs) {
          const {
            download,
            rel,
            target
          } = hrefAttrs;
          download != null && (plainDOMProps.download = download), rel && (plainDOMProps.rel = rel), typeof target == "string" && (plainDOMProps.target = target.charAt(0) !== "_" ? `_${target}` : target);
        }
        return plainDOMProps;
      }
    }
  },
  useEvents(viewProps, events, splitStyles, setStateShallow, staticConfig) {
  }
});
var View2 = View;
var Stack2 = Stack;
var Text2 = Text;

export {
  createStyledContext,
  ComponentContext,
  useConfiguration,
  GroupContext,
  useCreateShallowSetState,
  isWeb,
  isServer,
  isClient,
  useIsomorphicLayoutEffect,
  isChrome,
  isWebTouchable,
  isTouchable,
  isAndroid,
  isIos,
  currentPlatform,
  setConfig,
  getConfig,
  getTokens,
  getToken,
  getTokenValue,
  getThemes,
  updateConfig,
  setupDev,
  matchMedia,
  mediaState,
  mediaQueryConfig,
  getMedia,
  useMedia,
  mediaObjectToString,
  simpleHash,
  clamp,
  composeEventHandlers,
  StyleObjectProperty,
  StyleObjectValue,
  StyleObjectIdentifier,
  StyleObjectPseudo,
  StyleObjectRules,
  shouldRenderNativePlatform,
  tokenCategories,
  stylePropsUnitless,
  stylePropsTransform,
  stylePropsView,
  stylePropsTextOnly,
  stylePropsText,
  stylePropsAll,
  validPseudoKeys,
  validStyles,
  withStaticProperties,
  createVariable,
  variableToString,
  isVariable,
  getVariable,
  getVariableValue,
  getVariableName,
  forceUpdateThemes,
  useTheme,
  setRef,
  composeRefs,
  useComposedRefs,
  transformsToString,
  getCSSStylesAtomic,
  ClientOnly,
  useDidFinishSSR,
  Theme,
  themeable,
  Slot,
  Slottable,
  createComponent,
  Unspaced,
  Spacer,
  spacedChildren,
  getExpandedShorthand,
  getShorthandValue,
  getThemeCSSRules,
  isTamaguiComponent,
  isTamaguiElement,
  proxyThemeToParents,
  ensureThemeVariable,
  createFont,
  createShorthands,
  insertFont,
  createTheme,
  createTokens,
  setupReactNative,
  styled,
  useIsTouchDevice,
  Stack,
  useProps,
  useStyle,
  usePropsAndStyle,
  useThemeName,
  Configuration,
  FontLanguage,
  Text,
  useGet,
  useEvent,
  PresenceContext,
  ResetPresence,
  usePresence,
  useIsPresent,
  isPresent,
  createMedia,
  LayoutMeasurementController,
  setOnLayoutStrategy,
  TamaguiProvider2 as TamaguiProvider,
  createTamagui2 as createTamagui,
  View2 as View,
  Stack2,
  Text2
};
//# sourceMappingURL=chunk-VU4IMXNY.js.map
