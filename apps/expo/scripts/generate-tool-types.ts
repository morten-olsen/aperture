import { readFileSync, writeFileSync } from 'node:fs';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = resolve(__dirname, '..');
const snapshotPath = resolve(rootDir, 'tools.snapshot.json');
const outputPath = resolve(rootDir, 'src/generated/tools.ts');

type JSONSchema = {
  type?: string;
  properties?: Record<string, JSONSchema>;
  required?: string[];
  items?: JSONSchema;
  enum?: string[];
  anyOf?: JSONSchema[];
  description?: string;
  additionalProperties?: boolean;
  $schema?: string;
};

type ToolEntry = {
  id: string;
  description: string;
  tag?: string;
  input: JSONSchema;
  output: JSONSchema;
};

const jsonSchemaToTs = (schema: JSONSchema, indent = 0): string => {
  const pad = '  '.repeat(indent);

  if (schema.anyOf) {
    const types = schema.anyOf.map((s) => jsonSchemaToTs(s, indent));
    return types.join(' | ');
  }

  if (schema.enum) {
    return schema.enum.map((v) => JSON.stringify(v)).join(' | ');
  }

  switch (schema.type) {
    case 'string':
      return 'string';
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'null':
      return 'null';
    case 'array': {
      const itemType = schema.items ? jsonSchemaToTs(schema.items, indent) : 'unknown';
      return `${itemType}[]`;
    }
    case 'object': {
      if (!schema.properties || Object.keys(schema.properties).length === 0) {
        return 'Record<string, unknown>';
      }
      const requiredSet = new Set(schema.required ?? []);
      const fields = Object.entries(schema.properties).map(([key, prop]) => {
        const optional = requiredSet.has(key) ? '' : '?';
        const type = jsonSchemaToTs(prop, indent + 1);
        return `${pad}  ${key}${optional}: ${type};`;
      });
      return `{\n${fields.join('\n')}\n${pad}}`;
    }
    default:
      return 'unknown';
  }
};

const stripUserId = (schema: JSONSchema): JSONSchema => {
  if (schema.type !== 'object' || !schema.properties) return schema;
  const properties = Object.fromEntries(Object.entries(schema.properties).filter(([k]) => k !== 'userId'));
  const required = (schema.required ?? []).filter((k) => k !== 'userId');
  return {
    ...schema,
    properties,
    required: required.length > 0 ? required : undefined,
  };
};

const generate = async () => {
  const args = process.argv.slice(2);
  const serverIdx = args.indexOf('--server');
  const snapshotIdx = args.indexOf('--snapshot');

  let data: { tools: ToolEntry[] };

  if (serverIdx !== -1 && args[serverIdx + 1]) {
    const serverUrl = args[serverIdx + 1];
    console.log(`Fetching tools from ${serverUrl}/tools ...`);
    const response = await fetch(`${serverUrl}/tools`);
    if (!response.ok) {
      throw new Error(`Failed to fetch tools: ${response.status}`);
    }
    data = (await response.json()) as { tools: ToolEntry[] };
    writeFileSync(snapshotPath, JSON.stringify(data, null, 2) + '\n');
    console.log(`Saved snapshot to ${snapshotPath}`);
  } else {
    const file = snapshotIdx !== -1 && args[snapshotIdx + 1] ? args[snapshotIdx + 1] : snapshotPath;
    console.log(`Reading snapshot from ${file} ...`);
    data = JSON.parse(readFileSync(file, 'utf-8')) as { tools: ToolEntry[] };
  }

  const lines: string[] = ['// Auto-generated by scripts/generate-tool-types.ts â€” do not edit manually', ''];

  const toolIds = data.tools.map((t) => t.id);

  // ToolId union
  lines.push(`type ToolId = ${toolIds.map((id) => JSON.stringify(id)).join(' | ')};`);
  lines.push('');

  // ToolInputMap
  lines.push('type ToolInputMap = {');
  for (const tool of data.tools) {
    const stripped = stripUserId(tool.input);
    const ts = jsonSchemaToTs(stripped, 1);
    lines.push(`  ${JSON.stringify(tool.id)}: ${ts};`);
  }
  lines.push('};');
  lines.push('');

  // ToolOutputMap
  lines.push('type ToolOutputMap = {');
  for (const tool of data.tools) {
    const ts = jsonSchemaToTs(tool.output, 1);
    lines.push(`  ${JSON.stringify(tool.id)}: ${ts};`);
  }
  lines.push('};');
  lines.push('');

  // Helper types
  lines.push('type ToolInput<T extends ToolId> = ToolInputMap[T];');
  lines.push('type ToolOutput<T extends ToolId> = ToolOutputMap[T];');
  lines.push('');
  lines.push('export type { ToolId, ToolInputMap, ToolOutputMap, ToolInput, ToolOutput };');
  lines.push('');

  writeFileSync(outputPath, lines.join('\n'));
  console.log(`Generated ${outputPath} with ${data.tools.length} tools`);
};

generate().catch((err) => {
  console.error(err);
  process.exit(1);
});
